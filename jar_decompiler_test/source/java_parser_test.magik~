_package user
$

#remex(:java_parser_test)

_pragma(classify_level=restricted, topic={jar_decompiler, test})
def_slotted_exemplar(:java_parser_test,
	{},
	:test_case)
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_package()

	_local s << deco:lexical_scanner.new("package magik.decompile_target;".read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_package), "should be package")
	_self.assert_equals("magik.decompile_target", node.name)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_import()

	_local s << deco:lexical_scanner.new("import magik.decompile_target;".read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_import), "should be import")
	_self.assert_equals("magik.decompile_target", node.name)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_invocation()
	##
	_local inp << write_string("obj.dothing()")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()

	_self.assert_true(node.is_kind_of?(deco:jpn_method_invocation), "should be an invocation")
	_self.assert_equals("obj", node.sender.name)
	_self.assert_equals("dothing", node.name)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_self_method_invocation()
	##
	_local inp << write_string("dothing()")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()

	_self.assert_true(node.is_kind_of?(deco:jpn_method_invocation), "should be an invocation")
	_self.assert_true(node.sender.is_class_of?(deco:jpn_this))
	_self.assert_equals("dothing", node.name)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_concat_method_invocation()
	##
	_local inp << write_string("obj.dothing().doanother()")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_method_invocation), "should be an invocation")
	_self.assert_equals("doanother", node.name)
	_self.assert_true(node.sender.is_kind_of?(deco:jpn_method_invocation), "should be a nested invocation")
	_self.assert_equals("dothing", node.sender.name)

_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_invocation_with_args()
	##
	_local inp << write_string("obj.dothing(x, y)")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_method_invocation), "should be an invocation")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_invocation_with_method_handle_args()
	##
	_local inp << write_string("obj.dothing((MethodHandle)cfr_ldc_0() )")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_method_invocation), "should be an invocation")
	_self.assert_true(node.args[1].expression.is_kind_of?(deco:jpn_method_invocation))
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_invocation_with_casted_args()
	##
	_local inp << write_string("obj.dothing((Object) x)")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_method_invocation), "should be an invocation")
	_global x
	x << node
	_self.assert_true(node.args[1].expression.is_kind_of?(deco:jpn_variable))
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_assignment()
	##
	_local inp << write_string("AType t = obj.dothing()")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_assignment), "should be an assignment")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_array_type_assignment()
	##
	_local inp << write_string("AType[] t = obj.dothing()")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_assignment), "should be an assignment")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_array_type_direct_assignment()
	##
	_local inp << write_string("AType[] t = new Object[2]")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_assignment), "should be an assignment")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class()
	_local inp << write_string("public class deco_test_34 {", newline_char, "}")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_class), "should be class")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_new()
	##
	_local inp << write_string("new aClass()")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_new), "should be new")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_declaration()
	##
	_local inp << write_string("ResultTuple resultTuple;")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_statement()
	_self.assert_true(node.is_kind_of?(deco:jpn_declaration), "should be declaration")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_return()
	##
	_local inp << write_string("return avar;")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_statement()
	_self.assert_true(node.is_kind_of?(deco:jpn_return), "should be return")
	_self.assert_true(node.expression.is_kind_of?(deco:jpn_variable, "should be returning a variable"))
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_new_with_args()
	##
	_local inp << write_string("new aClass( obj, thing)")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_new), "should be new")
	_self.assert_equals(2, node.args.size)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_throw()
	##
	_local inp << write_string("throw x;")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_throw), "should be throw")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_throw_new()
	##
	_local inp << write_string("throw new IllegalArgumentException(except);")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_throw), "should be throw")
	_self.assert_true(node.expression.is_kind_of?(deco:jpn_new), "should be throwing a new")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class_annotation()
	##
	_local inp << write_string("@Override", newline_char,
				   "@SourceHash(value=888600578)", newline_char,
				   "@Debugger(method='MagikDebug')", newline_char,
				   "@CodeType(value='Subsidiary')", newline_char,
				   "public class a_class {}"
		      )
	inp << inp.substitute_character(%', %")

	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local node << p.get()

	_self.assert_true(node.is_class_of?(deco:jpn_class))
	_self.assert_equals(4,node.annotations.size)
	_self.assert_equals("Override", node.annotations[1].name)
	_self.assert_equals("888600578", node.annotations[2].value)
	_self.assert_equals("MagikDebug", node.annotations[3].value)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_nested_annotation()
	##
	_local inp << write_string("@EnvVars(value={",
				   "@EnvVar(name='__dynamic_frame__', type=Object.class, start=21, end=53, index=0), ",
				   "@EnvVar(name='_self', type=Object.class, start=13, end=54, index=1)})", newline_char,
				   "public class a_class {}")
	inp << inp.substitute_character(%', %")

	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local node << p.get()

	_self.assert_true(node.is_class_of?(deco:jpn_class))
	_self.assert_equals(1,node.annotations.size)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class_with_implements()
	_local inp << write_string("public class a_class ", newline_char,
				   "implements ExecutableMagik {",
				   "}")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_class), "should be class")
	_self.assert_equals("a_class", node.name)
	_self.assert_equals("ExecutableMagik", node.implementation)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class_with_error()
	_local inp << write_string("public class a_class_name")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_try _with e
		_local node << p.get()

		_self.assert_true(_true, "Should have thrown an error")
	_when deco_expected_separator
		_self.assert_equals(1, e[:line], "Line should be 1")
		_self.assert_equals(26, e[:column], "Column should be 26")
	_endtry
_endmethod
$



_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_with_args()
	_local inp << write_string(
			      "public static Object deco_test__test(Object _self) {",newline_char,
			      "}",newline_char)
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_method("deco_test")
	_self.assert_equals(1, m.args.size)
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_definition_without_args()
	##
	_local inp << write_string(
			      "public static Object deco_test__test1() {", newline_char,
			      "}")
	inp << inp.substitute_character(%', %")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_method("deco_test")
	_self.assert_true(m.is_kind_of?(deco:jpn_method), "Should be an body")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_casting()
	_local inp << write_string(
			      "(Object)a_var")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local c << p.parse_expression()
	_self.assert_true(c.is_kind_of?(deco:jpn_cast), "should be cast")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_array_casting()
	_local inp << write_string(
			      "(Object[])a_var")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local c << p.parse_expression()
	_self.assert_true(c.is_kind_of?(deco:jpn_cast), "should be cast")
	_self.assert_true(c.type.array?, "should be an array type")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_keyword_casting()
	_local inp << write_string(
			      "(int)a_var")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local c << p.parse_expression()
	_self.assert_true(c.is_kind_of?(deco:jpn_cast), "should be cast")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_keyword_array_casting()
	_local inp << write_string(
			      "(int[])a_var")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local c << p.parse_expression()
	_self.assert_true(c.is_kind_of?(deco:jpn_cast), "should be cast")
	_self.assert_true(c.type.array?, "should be an array type")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_if()
	##
	_local inp << write_string("if (thing.value()) { this.do_if(); };")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_expression()
	_self.assert_true(m.is_kind_of?(deco:jpn_if), "should be an if statement")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_if_else()
	##
	_local inp << write_string("if (thing.value()) { this.do_if(); } else { thing.do_else();};")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_expression()
	_self.assert_true(m.is_kind_of?(deco:jpn_if), "should be an if statement")
	_self.assert_true(m.else _isnt _unset , "should be an else statement")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_try_catch()
	_local inp << write_string(
			      "	try {", newline_char,
			      "            _self.in_try()", newline_char,
			      "        }", newline_char,
			      "        catch (Throwable throwable) {", newline_char,
			      "            _self.in_catch();", newline_char,
			      "        }")

	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local m << p.parse_expression()

	_self.assert_true(m.is_kind_of?(deco:jpn_try), "should be an try")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_try_catches()
	_local inp << write_string(
			      "	try {", newline_char,
			      "            _self.in_try()", newline_char,
			      "        }", newline_char,
			      "        catch (NoSuchMethodException | IllegalAccessException throwable) {", newline_char,
			      "            _self.in_catch();", newline_char,
			      "        }")

	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local m << p.parse_expression()

	_self.assert_true(m.is_kind_of?(deco:jpn_try), "should be an try")
	_self.assert_equals(m.exceptions.size, 2)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_xxx()
	_local inp << write_string("resultTuple = ResultTuple.EMPTY_TUPLE;")
	inp << inp.substitute_character(%', %")

	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local m << p.parse_expression()
	#debug_print(m.right)
	#_self.assert_true(m.right.is_kind_of?(deco:jpn_method_invocation), "should be a method invoc")
_endmethod
$
