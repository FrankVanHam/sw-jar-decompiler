_package user
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
def_slotted_exemplar(:java_parser_test,
	{},
	:test_case)
$


_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_package()

	_local s << deco:lexical_scanner.new("package magik.decompile_target;".read_stream())
	_local p << deco:java_parser.new(s)
	
	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_package), "should be package")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_import()

	_local s << deco:lexical_scanner.new("import magik.decompile_target;".read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_import), "should be import")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class()
	_local inp << write_string("public class deco_test_34 {", newline_char, "}")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_class), "should be class")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_new()
	##
	_local inp << write_string("new aClass()")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_new), "should be new")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_new_with_args()
	##
	_local inp << write_string("new aClass( obj, thing)")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_new), "should be new")
	_self.assert_equals(2, node.args.size)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_throw()
	##
	_local inp << write_string("throw x;")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_throw), "should be throw")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_throw_new()
	##
	_local inp << write_string("throw new IllegalArgumentException(except);")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.parse_expression()
	_self.assert_true(node.is_kind_of?(deco:jpn_throw), "should be throw")
	_self.assert_true(node.expression.is_kind_of?(deco:jpn_new), "should be throwing a new")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class_annotation()
	##
	_local inp << write_string("@Override", newline_char,
				   "@SourceHash(value=888600578)", newline_char,
				   "@Debugger(value='MagikDebug')", newline_char,
				   "@CodeType(value='Subsidiary')", newline_char,
				   "public class a_class {}"
		      )
	inp << inp.substitute_character(%', %")
	
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local node << p.get()
	
	_self.assert_true(node.is_class_of?(deco:jpn_class))
	_self.assert_equals(4,node.annotations.size)
	_self.assert_equals("Override", node.annotations[1].name)
	_self.assert_equals("888600578", node.annotations[2].value)
	_self.assert_equals("MagikDebug", node.annotations[3].value)
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class_with_implements()
	_local inp << write_string("public class a_class ", newline_char,
				   "implements ExecutableMagik {",
				   "}")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_class), "should be class")
	_self.assert_equals("a_class", node.name)
	_self.assert_equals("ExecutableMagik", node.implementation)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class_with_error()
	_local inp << write_string("public class a_class_name")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_try _with e
		_local node << p.get()

		_self.assert_true(_true, "Should have thrown an error")
	_when deco_expected_separator
		_self.assert_equals(1, e[:line], "Line should be 1")
		_self.assert_equals(26, e[:column], "Column should be 26")
	_endtry
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_base_complete_class()
	_local inp << write_string(
			      "public class a_class {", newline_char,
			      "    public static Object class__a_method() {",
			      "    }",
			      "}")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_class), "should be class")
	_self.assert_equals(1, node.methods.size, "should have one method")

	_local m << node.methods[1]
	_self.assert_true(m.args.empty?, "should have no args")
	_self.assert_true(m.body.empty?, "should have no body")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_class_method_with_annotation()
	_local inp << write_string(
			      "public class a_class {", newline_char,
			      "@Override", newline_char,
			      "@SourceHash(value=888600578)", newline_char,
			      "@Debugger(value='MagikDebug')", newline_char,
			      "@CodeType(value='Subsidiary')", newline_char,
			      "    public static Object class__a_method() {",
			      "    }",
			      "}")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local node << p.get()
	_self.assert_true(node.is_kind_of?(deco:jpn_class), "should be class")
	_self.assert_equals(1, node.methods.size, "should have one method")

	_local m << node.methods[1]
	_self.assert_true(m.args.empty?, "should have no args")
	_self.assert_true(m.body.empty?, "should have no body")
	_self.assert_equals(4, m.annotations.size)
	
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_with_args()
	_local inp << write_string(
			      "public static Object deco_test__test(Object _self) {",newline_char,
			      "}",newline_char)
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_method()
	_self.assert_equals(1, m.args.size)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_return_plus_method()
	_local inp << write_string(
			      "public static Object deco_test__test() {",newline_char,
			      "return BinaryDispatcher.bootstrap(",
			      %", "+", %",
			      ", Integer.valueOf(10), Integer.valueOf(1));",newline_char,
			      "}",newline_char)
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_method()
	_self.assert_equals(1, m.body.size)
	_local stat << m.body[1]
	_self.assert_true(stat.is_kind_of?(deco:jpn_return), "Return ")

	_local exp << stat.expression
	_self.assert_true(exp.is_kind_of?(deco:jpn_method_invocation), "returning a method invoc")

	_self.assert_equals(3,exp.args.size)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_method_invocation_without_args()
	##
#	_method deco_test.test1()
#	   _self.test()
#       _endmethod
#
	_local inp << write_string(
			      "public static Object deco_test__test1(Object _self) {", newline_char,
			      "ResultTuple cfr_ignored_1 = (ResultTuple)((Object)Invoker.tupleBootstrapPrivate('test()', (Object)_self));", newline_char,
			      "return ResultTuple.EMPTY_TUPLE;", newline_char,
			      "}")
	inp << inp.substitute_character(%', %")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	
	_local m << p.parse_method()
	_self.assert_true(m.body[1].is_kind_of?(deco:jpn_assignment), "Should be an assigmnent")
	_self.assert_true(m.body[2].is_kind_of?(deco:jpn_return), "Should be an return statement")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_statement_and_return()
	_local inp << write_string(
			      "public static Object deco_test__test() {",newline_char,
			      "ProcInvoker.naturalBootstrap(", %", "()", %", ");", newline_char,
			      "return BinaryDispatcher.bootstrap("+", Integer.valueOf(10), Integer.valueOf(1));",newline_char,
			      "}",newline_char)
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_method()
	_self.assert_equals(2, m.body.size)
	_local stat << m.body[1]
	_self.assert_true(stat.is_kind_of?(deco:jpn_method_invocation), "should be a statement")
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_casting()
	_local inp << write_string(
			      "public static Object deco_test__test() {",newline_char,
			      "return (Object)BinaryDispatcher.bootstrap("+");",newline_char,
			      "}",newline_char)
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_method()
	_local ret << m.body[1]
	_self.assert_true(ret.is_kind_of?(deco:jpn_return), "should be a return statement")
	_self.assert_true(ret.expression.is_kind_of?(deco:jpn_cast), "should be cast")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_if()
	##
	_local inp << write_string("if (thing.value()) { this.do_if(); };")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_expression()
	_self.assert_true(m.is_kind_of?(deco:jpn_if), "should be an if statement")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_if_else()
	##
	_local inp << write_string("if (thing.value()) { this.do_if(); } else { thing.do_else();};")
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_expression()
	_self.assert_true(m.is_kind_of?(deco:jpn_if), "should be an if statement")
	_self.assert_true(m.else _isnt _unset , "should be an else statement")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_try_catch()
	_local inp << write_string(		      
			      "	try {", newline_char, 
			      "            _self.in_try()", newline_char, 
			      "        }", newline_char, 
			      "        catch (Throwable throwable) {", newline_char, 
			      "            _self.in_catch();", newline_char, 
			      "        }")
	
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local m << p.parse_expression()
	
	_self.assert_true(m.is_kind_of?(deco:jpn_try), "should be an try")
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_try_catches()
	_local inp << write_string(		      
			      "	try {", newline_char, 
			      "            _self.in_try()", newline_char, 
			      "        }", newline_char, 
			      "        catch (NoSuchMethodException | IllegalAccessException throwable) {", newline_char, 
			      "            _self.in_catch();", newline_char, 
			      "        }")
	
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)
	_local m << p.parse_expression()
	
	_self.assert_true(m.is_kind_of?(deco:jpn_try), "should be an try")
	_self.assert_equals(m.exceptions.size, 2)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.test_simple_exemplar_and_method()
	_local inp << _self.simple_test_source_code()
	_local s << deco:lexical_scanner.new(inp.read_stream())
	_local p << deco:java_parser.new(s)

	_local m << p.parse_file()
	_self.assert_true(m.is_kind_of?(deco:jpn_file), "should be a file")
	_self.assert_equals(2, m.content.size)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler, test})
_method java_parser_test.simple_test_source_code()
	_local inp << write_string(
			      "public class deco_test_34 {", newline_char,
			      "    public static Object deco_test__test(Object _self) {", newline_char,
			      "        return BinaryDispatcher.bootstrap('+', Integer.valueOf(10), Integer.valueOf(1));", newline_char,
			      "    }", newline_char,
			      "}", newline_char,
			      "public class deco_test_33", newline_char,
			      "implements ExecutableMagik {", newline_char,
			      "    @Override", newline_char,
			      "    public Object execute() {", newline_char,
			      "        DynamicAccessor.bootstrapStorer('!source_file!', 'sw', (Object)ConstantBuilder.stringBootstrap('symbol', 'E:\\jar_decompiler\\decompile_target\\source\\deco_test.magik'));", newline_char,
			      "        DynamicAccessor.bootstrapStorer('!current_package!', 'sw', (Object)ProcInvoker.bootstrap('()', GlobalAccessor.bootstrapFetcher2('fetchGlobal2', 'sw', 'package'), ConstantBuilder.stringBootstrap('symbol', 'user')));", newline_char,
			      "        ProcInvoker.naturalBootstrap('()', (Object)GlobalAccessor.bootstrapFetcher2('fetchGlobal2', 'sw', 'def_slotted_exemplar'), (Object)ConstantBuilder.symbolBootstrap('symbol', 'deco_test'), (Object)VectorBuilder.EMPTY_VECTOR);", newline_char,
			      "        return TupleBuilder.bootstrap('tb', MagikObjectUtils.createMethod('deco_test', 'test()', deco_test_34.class, 'deco_test__test', 1, 1));", newline_char,
			      "    }", newline_char,
			      "}", newline_char )
	inp << inp.substitute_character(%', %")
	>> inp
_endmethod
$
