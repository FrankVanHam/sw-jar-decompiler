_package deco
$

#remex(:lexical_scanner)
$
_pragma(classify_level=restricted, topic={jar_decompiler})
##
## Scans a stream and outputs lexemes.
##
def_slotted_exemplar(:lexical_scanner,
	{
		{:in, _unset},
		{:line, _unset},
		{:column, _unset}
	})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
lexical_scanner.define_shared_constant(:operators,
	equality_set.new_with("+", "-", "*", "/", "%", "^", "&", "|", "!", "~", "=", "+=", "-=", "*=", "/=", "%=", "^=", "++", "--", "==", "!=", "<", ">", "&=", ">>=", "<<=", ">=", "<=", "||", "&&", ">>", "<<", "?", ":"), #"
	:private)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
lexical_scanner.define_shared_constant(:operator_characters,
	set.new_with(%%,%&,%*,%+,%-,%/,%|,%~,%^,%:,%<,%=,%>,%?,%!),
	:private)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
lexical_scanner.define_shared_constant(:separators,
	set.new_with(%[, %], %(, %), %{, %}, %,, %;, %., %" ),
	:private)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
lexical_scanner.define_shared_constant(:keywords,
	equality_set.new_with("abstract","continue","for","new","switch","assert","default","goto",
			      "package","synchronized","boolean","do","if","private","this","break",
			      "double","implements","protected","throw","byte","else","import","public",
			      "throws","case","enum","instanceof","return","transient","catch","extends",
			      "int","short","try","char","final","interface","static","var",
			      "class","finally","long","strictfp","void","const","float",
			      "native","super","volatile","while","package","import",
			      "class","if","then","else"),
	:private)
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.new(p_stream)
	>> _clone.init(p_stream)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method lexical_scanner.init(p_stream)
	.in << peekable_input_stream.new(p_stream)
	.line << 1
	.column << 1
	 >> _self 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get()
	_loop
		_if _self.more_to_get?.not _then _return lexeme.new_eof(.line, .column) _endif
		
		_local char << _self.peek_char()
		
		_if char.white_space?.not
		_then
			_if char = %/
			_then
				_self.get_char()
				_self.get_comment()
			_elif char = %"
			_then
				_self.get_char()
				_return _self.get_string()
			_elif char = %'
			_then
				_self.get_char()
				_return _self.get_character()
			_elif char = %@
			_then
				_return _self.get_annotation()
			_elif _self.separators.includes?(char)
			_then
				_return _self.get_separator()
			_elif _self.operator_characters.includes?(char)
			_then
				_return _self.get_operator()
			_elif char.decimal_digit?
			_then
				_return _self.get_number()
			_else 
				_return _self.get_keyword_or_identifier()
			_endif 
		_else
			_self.get_char()
		_endif
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_separator()
	_local ch << _self.get_char()
	_local next << _self.peek_char()
	_if next = %.
	_then
		_self.get_char()
		_self.get_char()
		_return lexeme.new_separator("...", .line, .column)
	_else 
		_return lexeme.new_separator(ch.write_string, .line, .column)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_operator()
	##
	_local s << internal_text_output_stream.new()
	_loop 
		s.write(_self.get_char())
		
		_if _self.more_to_get?.not _then _leave _endif
		
		_local peek << _self.peek_char()
		_if _self.operator_characters.includes?(peek).not 
		_then
			_leave
		_endif
		_if _self.operators.includes?(write_string(s.string,peek)).not
		_then
			_leave
		_endif 
	_endloop
	_local value << s.string
	>> lexeme.new_operator(value, .line, .column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_comment()
	##
	_local char << _self.peek_char()
	>> _if char = %/
	   _then
		   >> lexeme.new_comment(_self.get_upto(newline_char), .line, .column)
	   _else 
		   >> lexeme.new_comment(_self.get_upto(%/), .line, .column)
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_string()
	## 
	>> lexeme.new_string(_self.get_upto(%"), .line, .column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_character()
	##
	_local str << _unset 
	_local char << _self.peek_char()
	_if char = %\
	_then
		_self.get_char() #\
		str << _self.get_char().write_string
		_self.get_char() #'
	_else
		str << _self.get_char().write_string
		_self.get_char() #'
	_endif 
	>> lexeme.new_string(str, .line, .column)
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_annotation()
	##
	_self.get_char()
	>> lexeme.new_annotation(_self.get_token(), .line, .column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_keyword_or_identifier()
	##
	_local value << _self.get_token()
	>> _if _self.keywords.includes?(value)
	   _then
		   >> lexeme.new_keyword(value, .line, .column)
	   _else
		   >> lexeme.new_identifier(value, .line, .column)
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_number()
	##
	>> lexeme.new_number(_self.get_number_token(), .line, .column)
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_number_token()
	##
	## Get the next string upto a space, newline or an operator.
	##
	_local out << internal_text_output_stream.new()
	_loop
		_if _self.more_to_get?.not _then _leave _endif 
		_local char << _self.peek_char()
		
		_if char.decimal_digit? _orif (char = %.)
		_then
			out.write(_self.get_char())
		_else
			_leave 
		_endif
	_endloop
	>> out.string
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_token()
	##
	## Get the next string upto a space, newline or an operator.
	##
	_local out << internal_text_output_stream.new()
	_loop
		_if _self.more_to_get?.not _then _leave _endif

		_local str << _self.proces_special_construct()
		_if str.empty?.not
		_then
			out.write(str)
			_continue
		_endif 
		
		_local char << _self.peek_char()	
		_if _not(char.white_space? _orif _self.separators.includes?(char) _orif _self.operator_characters.includes?(char))
		_then
			out.write(_self.get_char())
		_else
			_leave 
		_endif
	_endloop
	>> out.string
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.proces_special_construct()
	##
	## Special handling for the java decompiler failure to
	## decompile the method names property.
	
	_local char << _self.peek_char()
	_if (char = %?) _orif (char = %!)
	_then
		_return _self.get_char().write_string
	_endif 
	_if char = %( _andif _self.peek_char(2) = %) _andif
	    (_self.peek_char(3)=%\ _orif _self.peek_char(3)=%^)
	_then
		_self.get_char()
		_self.get_char()
		_return "()"
	_endif
	_if char = %\ _andif _self.peek_char(2) = %l
	_then
		_self.get_char()
		_self.get_char()
		_return "\l"
	_endif
	_if char = %^ _andif _self.peek_char(2) = %\
	_then
		_self.get_char()
		_return "^" 
	_endif
	_if char = %\ _andif _self.peek_char(2) = %b _andif _self.peek_char(3)=%]
	_then
		_self.get_char()
		_self.get_char()
		_self.get_char()
		_return "\b]" 
	_endif
	_return "" 
_endmethod
$



_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_upto(p_end_char)
	##
	## Get a string next upto the P_END_CHAR
	##
	_local out << internal_text_output_stream.new()
	_loop
		_if _self.more_to_get?.not _then _leave _endif 
		_local char << _self.peek_char()
		
		_if char <> p_end_char
		_then
			out.write(_self.get_char())
		_else
			# take the last char and stop
			_self.get_char()
			_leave
		_endif
	_endloop
	>> out.string
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.get_char()
	_local ch << .in.get()
	_if ch _is newline_char
	_then
		.line +<< 1
		.column << 0
	_else
		.column +<< 1
	_endif
	>> ch
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.peek_char(_optional how_far)
	>> .in.peek(how_far)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexical_scanner.more_to_get?
	>> .in.more_to_get?
_endmethod
$
