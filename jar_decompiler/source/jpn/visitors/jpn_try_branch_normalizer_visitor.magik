_package deco
$

#remex(:jpn_try_branch_normalizer_visitor)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_try_branch_normalizer_visitor,
	{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.new()
	>> _clone.init()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method jpn_try_branch_normalizer_visitor.init()
	>> _self 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.accept(p_body)
	##
	_local sts << p_body.statements

#	_global x
#	x << sts
#	666.stop
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		(ok?, branch_index) << _self.merge_when_in_current_body_branch?(i_node)
		_if ok?
		_then
			sts[i_index] << _self.merge_when_in_current_body_branch(i_node, branch_index)
		_endif
		ok? << _self.merge_when_in_upper_body_branch?(i_node)
		_if ok?
		_then
			sts[i_index] << _self.merge_when_in_upper_body_branch(i_node)
		_endif
		ok? << _self.merge_branch_in_upper_upper_body_branch?(i_node)
		_if ok?
		_then
			sts[i_index] << _self.merge_branch_in_upper_upper_body_branch(i_node)
		_endif 
#		ok? << _self.subbranch_need_reformats?(i_node)
#		_if ok?
#		_then
#			sts[i_index] << _self.reformat_subbranch(i_node)
#		_endif
#		ok? << _self.subbranch_need_reformats2?(i_node)
#		_if ok?
#		_then
#			sts[i_index] << _self.reformat_subbranch2(i_node)
#		_endif
		(ok?, try_index) << _self.needs_elifing?(i_node)
		_if ok?
		_then
			sts[i_index] << _self.elif(i_node, try_index)
		_endif 
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.needs_elifing?(p_node)
	##
	(ok?, try_index) << jpn_try_visitor.is_try?(p_node)
	_if ok?
	_then 
		_local body_sts << p_node.body.statements
		_local c << 0
		_for i _over range(try_index+1, body_sts.size)
		_loop
			_local n << body_sts[i]
			_if n.is_class_of?(dcn_branch)
			_then
				c+<<1
			_endif 
		_endloop
		ok? << (c > 1)
	_endif 
	>> ok?, try_index
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.elif(p_node, p_try_index)
	##
	_local body_sts << p_node.body.statements
	_local base_branch
	_local running_tag << _unset 
	_for i _over range(p_try_index+1, body_sts.size)
	_loop
		_local n << body_sts[i]
		_if n.is_class_of?(dcn_branch)
		_then
			_if base_branch _is _unset
			_then
				base_branch << n
				running_tag << _self.break_for(n)
			_else
				this_tag << _self.break_for(n)
				_if this_tag _isnt _unset _andif
				    this_tag = running_tag
				_then
					base_branch.convert_last_to_or(n.if_condition)
				_else
					base_branch.input.add({n.if_condition, n.if_body})
				_endif
				running_tag << this_tag
				body_sts[i] << dcn_no_op.new()
			_endif
		_else
			body_sts[i] << dcn_no_op.new()
		_endif 
	_endloop
	>> p_node
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.subbranch_need_reformats2?(p_node)
	## 
	_if p_node.is_class_of?(dcn_block) _andif
	    p_node.body.statements.size > 0 _andif
	    p_node.body.statements[1].is_class_of?(dcn_block)
	_then
	    _if jpn_try_visitor.is_try?(p_node.body.statements[1])
	    _then
		    _return _true
	    _endif
	_endif 
	_return _false 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.reformat_subbranch2(p_node)
	_local body_sts << p_node.body.statements
	_local then_sts << body_sts.slice(2, body_sts.size).copy()
	
	_local last_block << p_node.body.statements[1]
	(ok?, b1, b2) << _self.branch_need_reformats2?(last_block, last_block.name)

	_if ok?
	_then 
		show(last_block.name, ok?, b1, b2)
		_local stats << last_block.body.statements
		_local cond
		_for i _over range(b1, b2)
		_loop
			_local n << stats[i]
			_if n.is_class_of?(dcn_branch)
			_then
				_if cond _is _unset
				_then
					cond << n.if_condition
				_else
					cond << dcn_op.new("_or", cond, n.if_condition)
				_endif
			_endif 
		_endloop
		_for i _over range(b1, b2)
		_loop
			stats[i] << dcn_no_op.new()
		_endloop 
		stats[b1] << dcn_branch.new( {{cond, dcn_body.new(then_sts)}})
		
		_for i _over range(2, body_sts.size)
		_loop
			body_sts[i] << dcn_no_op.new()
		_endloop
	_endif 
	>> p_node
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.subbranch_need_reformats?(p_node)
	## 
	_if p_node.is_class_of?(dcn_block) _andif
	    p_node.body.statements.size > 1 _andif
	    p_node.body.statements[2].is_class_of?(dcn_block) _andif
	    p_node.body.statements[2].body.statements.size > 0
	_then
	    _if jpn_try_visitor.is_try?(p_node.body.statements[2].body.statements[1])
	    _then
		    _return _true
	    _endif
	_endif 
	_return _false 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.merge_branch_in_upper_upper_body_branch?(p_node)
	##
	_if _self.block_in_try_buildup?(p_node) _andif
	    (up1 << _self.upper_block(p_node)) _isnt _unset _andif
	    (up2 << _self.upper_block(up1)) _isnt _unset _andif
	    _self.taxonomy_branches_in?(p_node) _andif
	    _self.taxonomy_branches_in?(up2)
	_then
		_return _true
	_else
		_return _false
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.merge_branch_in_upper_upper_body_branch(p_node)
	##
	_local tag << p_node.name
	_local my_b << _self.last_branch_in(p_node)

	_local up2 << _self.upper_block(_self.upper_block(p_node))
	_local upper_b << _self.last_branch_in(up2)
	
	upper_b.convert_to_or(my_b.if_condition)
	
	_self.clear_bottom_block_statements(p_node)
	>> p_node
_endmethod
$



_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.merge_when_in_upper_body_branch?(p_node)
	_if _self.block_in_try_buildup?(p_node) _andif
	    _self.taxonomy_branches_in?(p_node).not _andif
	    _self.bottom_block_statements(p_node).empty?.not 
	_then
		_return _true
	_else
		_return _false
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.merge_when_in_upper_body_branch(p_node)
	##
	# Find the last branch in the upper body and turn it into a
	# reverse branch with self bottom as the condition body.

	_local up_tag << _self.upper_block(p_node).name

	_local b << _unset 
	_local blck << _self.upper_block(p_node)
	_loop
		b << _self.branch_tagged(blck, up_tag)
		_if b _isnt _unset _then _leave _endif 
		
		blck << _self.upper_block(blck)
		_if blck _is _unset _then _leave _endif
	_endloop

	_if b _isnt _unset
	_then
		_local sts << _self.bottom_block_statements(p_node).copy()
		_self.clear_bottom_block_statements(p_node)

		_if b.if_condition.is_class_of?(dcn_not)
		_then 
			b.convert_to_not_with_body(dcn_body.new(sts))
		_else
			b.set_body(dcn_body.new(sts))
		_endif 
	_endif 
	>> p_node
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.branch_tagged(p_block_node, p_tag)
	##
	_local sts << p_block_node.body.statements
	_for i_index, i_stat _over sts.keys_and_elements_in_reverse()
	_loop 
		_if i_stat.is_class_of?(dcn_branch) _andif
		    jpn_try_visitor.taxonomy_includes_branch?(i_stat) _andif
		    _self.break_for(i_stat) = p_tag
		_then
			_return i_stat
		_endif
		_if i_stat.is_class_of?(dcn_break) _andif
		    i_stat.name = p_tag
		_then
			_return sts[i_index-1]
		_endif 
	_endloop
	_return _unset 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.break_for(p_branch_node)
	##
	_if p_branch_node.if_body _isnt _unset _andif
	    p_branch_node.if_body.statements.size > 1 _andif
	    p_branch_node.if_body.statements[1].is_class_of?(dcn_break)
	_then
		_return p_branch_node.if_body.statements[1].name
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.last_branch_in(p_node)
	##
	_for i_stat _over p_node.body.statements.elements_in_reverse()
	_loop 
		_if i_stat.is_class_of?(dcn_branch) _andif
		    jpn_try_visitor.taxonomy_includes_branch?(i_stat)
		_then
			_return i_stat
		_endif 
	_endloop
	_return _unset 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.taxonomy_branches_in?(p_node)
	##
	_for i_stat _over p_node.body.statements.fast_elements()
	_loop 
		_if i_stat.is_class_of?(dcn_branch) _andif
		    jpn_try_visitor.taxonomy_includes_branch?(i_stat)
		_then
			_return _true
		_endif 
	_endloop
	_return _false 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.block_in_try_buildup?(p_node)
	##
	_if p_node.is_class_of?(dcn_block).not _then _return _false _endif
	(ok?, try_index) << jpn_try_visitor.is_try?(p_node)
	_if ok?
	_then
		_return _true
	_endif 
	_local n << _self.upper_block(p_node)
	
	_if n _isnt _unset
	_then
		_return _self.block_in_try_buildup?(n)
	_else
		_return _false
	_endif	
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.upper_block(p_block_node)
	##
	_local index << _self.upper_block_index(p_block_node)
	>> _if index _isnt _unset
	   _then
		   >> p_block_node.body.statements[index]
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.bottom_block_statements(p_node)
	##
	_local b_index << _self.upper_block_index(p_node)
	_return p_node.body.statements.slice_to_end(b_index+1)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.clear_bottom_block_statements(p_node)
	##
	_local b_index << _self.upper_block_index(p_node)
	_local sts << p_node.body.statements
	_for i _over range(b_index+1, sts.size)
	_loop
		sts[i] << dcn_no_op.new()
	_endloop 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.upper_block_index(p_node)
	##
	_if p_node.body.statements.size>=1 _andif
	    p_node.body.statements[1].is_class_of?(dcn_block)
	_then
		_return 1
	_endif
	_if p_node.body.statements.size>=2 _andif
	    p_node.body.statements[2].is_class_of?(dcn_block)
	_then
		_return 2
	_endif
	_return _unset 
_endmethod
$




_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.merge_when_in_current_body_branch?(p_node)
	##
	(ok?, try_index) << jpn_try_visitor.is_try?(p_node)
	_if ok?
	_then
		_local body_sts << p_node.body.statements
		# find the not() branch
		_for i _over range(try_index+1, body_sts.size)
		_loop
			_local n << body_sts[i]
			_if n.is_class_of?(dcn_branch) _andif
			    jpn_try_visitor.taxonomy_includes_branch?(n) _andif
			    n.if_condition.is_class_of?(dcn_not)
			_then
				_return _true, i
			_endif
		_endloop
	_endif
	_return _false, _unset
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.branch_need_reformats2?(p_node, p_block_name)
	##
	(ok?, try_index) << jpn_try_visitor.is_try?(p_node)
	_local start, end 
	_if ok?
	_then
		_local body_sts << p_node.body.statements
		# find the not() branch
		_for i _over range(try_index+1, body_sts.size)
		_loop
			_local n << body_sts[i]
			_if n.is_class_of?(dcn_branch) _andif
			    jpn_try_visitor.taxonomy_includes_branch?(n)
			_then
				_local stat << n.if_body.statements[1]
				_if stat.is_class_of?(dcn_break) _andif
				    stat.name = p_block_name
				_then
					start << start.default(i).min(i)
					end << end.default(i).max(i)
				_endif 
			_endif
		_endloop
	_endif
	_return start _isnt _unset, start, end 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.reformat_subbranch(p_node)
	_local body_sts << p_node.body.statements
	_local then_sts << body_sts.slice(3, body_sts.size).copy()
	
	_local last_block << p_node.body.statements[2].body.statements[1]
	(ok?, branch_index) << _self.merge_when_in_current_body_branch?(last_block)

	_local block_sts << last_block.body.statements
	_local branch << block_sts[branch_index]
	block_sts[branch_index] << _self.convert_not_branch(branch, then_sts)
	
	_for i _over range(3, body_sts.size)
	_loop
		body_sts[i] << dcn_no_op.new()
	_endloop
	
	>> p_node
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.merge_when_in_current_body_branch(p_node, p_branch_index)
	##
	_local body_sts << p_node.body.statements
	_local branch << body_sts[p_branch_index]
	
	_local then_sts << body_sts.slice(p_branch_index+1, body_sts.size).copy()
	_for i _over range(p_branch_index+1, body_sts.size)
	_loop
		body_sts[i] << dcn_no_op.new()
	_endloop 
	
	body_sts[p_branch_index] << _self.convert_not_branch(branch, then_sts)
	>> p_node
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.convert_not_branch(branch, then_sts)
	## 
	_local cond << _self.construct_not_branch(branch)
	>> dcn_branch.new({{cond, dcn_body.new(then_sts)}})
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_branch_normalizer_visitor.construct_not_branch(branch)
	##
	_local cond << branch.if_condition.not
	_local last << branch.if_body.statements.last
	>> _if last.is_class_of?(dcn_branch)
	   _then
		   >> dcn_op.new("_or", cond, _self.construct_not_branch(last))
	   _else
		   >> cond
	   _endif 
_endmethod
$


