_package deco
$

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_pop_visitor,{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_pop_visitor.new()
	>> _clone 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_pop_visitor.accept(p_body)
	##
	_local sts << p_body.statements
	_local result << _unset
	_local result_reset? << _false 
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if _self.is_remainder?(i_node) _andif (result _isnt _unset)
		_then
			_if result_reset?.not
			_then
				result.reset()
				result_reset? << _true
			_endif 
			sts[i_index] << dcn_no_op.new()
		_elif _self.is_remainder_assignment?(i_node) _andif (result _isnt _unset)
		_then
			_if result_reset?.not
			_then
				result.reset()
				result_reset? << _true
			_endif
			result.set_gather(i_node.only_local())
			sts[i_index] << dcn_no_op.new()
		_elif _self.is_pop_assignment?(i_node) _andif (result _isnt _unset)
		_then
			_if result_reset?.not
			_then
				result.reset()
				result_reset? << _true
			_endif
			result.append_local(i_node.only_local())
			sts[i_index] << dcn_no_op.new()
			
		_elif _self.is_result_tuple?(i_node)
		_then
			# this should come last
			result << i_node
			result_reset? << _false	
		_endif 
	_endloop
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if _self.is_pop_assignment?(i_node)
		_then
			i_node.unpop()
		_endif 
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_pop_visitor.is_remainder?(p_node)
	>> p_node.is_class_of?(dcn_remainder)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_pop_visitor.is_remainder_assignment?(p_node)
	_if p_node.is_class_of?(dcn_local_assignment)
	_then
		_local loc << p_node.only_local()
		_if loc _isnt _unset
		_then
			_return p_node.expression.is_class_of?(dcn_remainder)
		_else
			_return _false
		_endif 
	_else
		_return _false
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_pop_visitor.is_pop_assignment?(p_node)
	_if p_node.is_class_of?(dcn_local_assignment)
	_then
		_local loc << p_node.only_local()
		_if loc _isnt _unset
		_then
			_return p_node.expression.is_class_of?(dcn_pop)
		_else
			_return _false
		_endif 
	_else
		_return _false
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_pop_visitor.is_result_tuple?(p_node)
	_if p_node.is_class_of?(dcn_local_assignment)
	_then
		_local loc << p_node.only_local()
		_if loc _isnt _unset
		_then
			
			_return loc.is_type?("ResultTuple") _orif loc.is_type?("Object")
		_else
			_return _false
		_endif 
	_else
		_return _false
	_endif 
_endmethod
$
