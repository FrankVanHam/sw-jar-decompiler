_package deco
$

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_block_if_visitor,{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_if_visitor.new()
	>> _clone 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_if_visitor.accept(p_body)
	##
	_local sts << p_body.statements
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if i_node.is_class_of?(dcn_block)
		_then
			_if _self.is_hidden_if?(i_node)
			_then
				sts[i_index] << _self.convert(i_node)
			_endif
		_endif 			
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_if_visitor.convert(p_block_node)
	##
	_local branch << p_block_node.body.statements[1]
	_local stats << p_block_node.body.statements.slice_to_end(2)
	_return dcn_branch.new(rope.new_with(
				       {branch.if_condition.expression,
					dcn_body.new(stats)}))
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_if_visitor.is_hidden_if?(p_block_node)
	##
	_local tag << p_block_node.name
	_if tag _is _unset _then _return _false, :missing_tag _endif

	_local block_body << p_block_node.body
	_if block_body.statements.size < 1 _then _return _false, :empty_block _endif

	_local br << block_body.statements[1]
	_if br.is_class_of?(dcn_branch).not _then _return _false, :first_is_not_branch _endif
	_if br.just_if?.not _then _return _false, :first_is_not_just_if _endif
	_if br.if_condition.is_class_of?(dcn_not).not _then _return _false, :first_is_not_not _endif

	_local if_body << br.if_body
	_if if_body.statements.size < 1 _then _return _false, :branch_body_empty? _endif
	
	_local break << if_body.statements[1]
	_if break.is_class_of?(dcn_break).not _then _return _false, :branch_body_is_break _endif
	_if break.name <> tag _then _return _false, :branch_body_break_not_matching_tag _endif

	_return _true 
_endmethod
$
