_package deco
$


#remex(:tblock_factory)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:tblock_factory,
	{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method tblock_factory.new()
	>> _clone.init()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method tblock_factory.init()
	>> _self 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method tblock_factory.create(p_node)
	##
	_if _self.is_block_or_try?(p_node).not
	_then
		_return _unset
	_else
		_local blck << first_block << _self.create_one(p_node)
		_loop
			_if blck _is _unset _then _leave _endif 
			_if blck.has_try? _then _leave _endif
			
			blck << _self.find_child(blck)
		_endloop
		
		_if blck _isnt _unset _andif blck.has_try?
		_then
			_return first_block
		_else
			_return _unset 
		_endif
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method tblock_factory.create_one(p_node)
	_if _self.is_block_or_try?(p_node).not
	_then
		_return _unset
	_endif 
	(try?, try_index) << _self.has_try?(p_node)
	>> _if try?
	   _then
		   _local tb << _if p_node.is_unfinished_try?
				_then >> tblock.new(p_node, :try)
				_else >> tblock.new(p_node, :try_block)
				_endif 
		   tb.start_index << try_index+1
		   >> tb
	   _elif p_node.is_class_of?(dcn_block)
	   _then 
		   >> tblock.new(p_node, :block)
	   _else
		   >> _unset 
	   _endif 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method tblock_factory.has_try?(p_node)
	_local sts << _if p_node.is_unfinished_try?
		      _then >>p_node.try_body.statements
		      _else >> p_node.body.statements
		      _endif 

	_local idx << _self.try_index(sts)
	
	>> idx _isnt _unset, idx
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method tblock_factory.try_index(sts)
	##
	_local idx
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if i_node.is_unfinished_try?
		_then
			idx << i_index
			_leave 
		_endif
	_endloop
	_if idx _is _unset _then _return _unset _endif
	_if idx < 7        _then _return _unset _endif
	
	_if sts[idx-1].is_dynamic_store?.not  _then _return _unset _endif 
	_if sts[idx-1].name <> "__catch_tags_dynamic__" _then _return _unset _endif
	
	>> idx
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method tblock_factory.find_child(p_tblock)
	##
	_local idx << _self.child_block_index(p_tblock)
	_if idx _isnt _unset
	_then
		_local child << _self.create_one(p_tblock.statements[idx])
		_if child _isnt _unset
		_then
			child.parent << p_tblock
			p_tblock.child << child
			p_tblock.start_index << idx+1
			_return child
		_endif
	_endif
	_return _unset
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method tblock_factory.child_block_index(p_tblock)
	##
	_local sts << p_tblock.statements
	_if sts.size >=1 _andif _self.is_block_or_try?(sts[1]) _then _return 1 _endif
	_if sts.size >=2 _andif _self.is_block_or_try?(sts[2]) _then _return 2 _endif
	_return _unset 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method tblock_factory.is_block_or_try?(p_node)
	>> p_node.is_class_of?(dcn_block) _orif
		p_node.is_unfinished_try?
_endmethod
$
