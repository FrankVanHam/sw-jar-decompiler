_package deco
$

#remex(:dcn_proc)
$

_pragma(classify_level=restricted, topic={decompiler})
## Represents a node for a decompiled proc from magik.
def_slotted_exemplar( :dcn_proc,
		      {
			      {:java_class_name, _unset},
			      {:java_method_name, _unset},
			      {:imports, _unset, :readable},
			      {:exemplar_name, _unset, :readable},
			      {:name, _unset, :readable},
			      {:private?, _unset ,:readable},
			      {:abstract?, _unset, :readable}
			      
		      }, :dcn_callable )
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.new(p_class_name, p_method_name, p_args, p_scatter?, p_body, p_imports)
	##
	>> _clone.init(p_class_name, p_method_name, p_args, p_scatter?, p_body, p_imports )
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_proc.init(p_class_name, p_method_name, p_args, p_scatter?, p_body, p_imports )

	assert(p_body.is_class_of?(dcn_body))

	.private? << _false 
	.abstract? << _false
	.java_class_name << p_class_name
	.java_method_name << p_method_name
	.imports << p_imports
	>> _super.init(p_args, p_scatter?, p_body)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.method_name
	>> .name.default("no_name_given_in_bind")
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.match_java?(p_class_name, p_method_name)
	##
	>> .java_class_name = p_class_name _andif
		.java_method_name = p_method_name
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.bind(p_name, p_nr_args, p_mandatory_args )
	##
	_if p_name.default("") <> ""
	_then
		.name << p_name
	_endif 
	.nr_mandatory_args << p_mandatory_args
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.abstract?
	>> .abstract? 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.private?
	>> .private?
_endmethod
$
_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.iter?
	>> _false 
_endmethod
$


_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.decode_on(a_stream)
	##
	## Write a formated output on the stream
	##
	#_self.decode_pragma_on(a_stream)
	a_stream.write( "_proc" )
	_if .name _isnt _unset
	_then
		a_stream.write(" @", .name)
	_endif 
	
	a_stream.write( "(" )
	_self.int!decode_args_on(a_stream, 1)
	a_stream.write( ")")
	a_stream.newline()
	a_stream.indent(4)
	_if .imports.empty?.not
	_then
		a_stream.write( "_import ")
		_self.decode_list_on(a_stream, .imports)
		a_stream.newline()
	_endif 
	
	#_self.decode_comment_on(a_stream)
	_self.decode_body_on(a_stream)
	a_stream.unindent(4)
	a_stream.newline()
	a_stream.write( "_endproc" )
_endmethod
$


#_pragma(classify_level=restricted, topic={decompiler})
### Represents a node for a decompiled method from magik.
#def_slotted_exemplar( :dcn_proc,
#		      {
#			      {:method, _unset}
#		      }, :dcn_callable )
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_method dcn_proc.new( p_method, statements, locals, literals )
#	_return _clone.init( p_method, statements, locals, literals )
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_proc.init( p_method, statements, locals, literals )
#	.method << p_method
#	.proc << .method.value
#	_return _super.init(p_method.value, statements, locals, literals )
#_endmethod
#$
#
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_proc.exemplar_name
#	_return .method.owner.meta_at(:class_name)
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_proc.method_name
#	_return .method.name
#_endmethod
#$
#
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_proc.iter?
#	_return .method.iter?
#_endmethod
#$
#


_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.magik_exemplar
	##
	_local name << .exemplar_name.as_symbol()
	_for i_pack _over !current_package!.all_packages.fast_elements()
	_loop
		_local glb << i_pack.global_at(name)
		_if glb _isnt _unset
		_then
			_return glb.value
		_endif
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proc.magik_method
	##
	_local exem << _self.magik_exemplar
	>> _if exem _isnt _unset
	   _then
		   >> exem.method(.name.as_symbol())
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_proc.comment
	_local met << _self.magik_method
	>> _if met _isnt _unset
	   _then 
		   >> compiler_info_provider.new().comment_for_method(met)
	   _endif 
_endmethod
$


_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_proc.level_topics_and_usages
	_local met << _self.magik_method
	>> _if met _isnt _unset
	   _then 
		   >> compiler_info_provider.new().level_topics_and_usages_for_method(met)
	   _else
		   >> _unset, {}, {}
	   _endif 
_endmethod
$

#
#_pragma(classify_level=restricted, topic={decompiler})
#_method dcn_proc.decode_args_on(a_stream)
#	
#	proc << .method.value
#	name << _self.method_name
#	a_stream.write( ".", name.slice( 1, name.size-2))
#	a_stream.write( "(" )
#	_if proc.num_args > 0
#	_then
#		_self.int!decode_args_on(a_stream, 1)
#	_endif 
#	a_stream.write( ")" )
#_endmethod
#$
#
#
##_pragma(classify_level=restricted, topic={decompiler})
##_method dcn_proc.last_node_in_method?(node)
##	_return _self.my_last_real_node?(node)
##_endmethod
##$
