_package deco
$

#remex(:jpn_execution_post_processor)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_execution_post_processor,{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_execution_post_processor.process_jar(p_jar)
	_for i_file _over p_jar.files.fast_elements()
	_loop
		_self.process_file(i_file)
	_endloop
_endmethod
$
	
_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_execution_post_processor.process_file(p_file)
	##
	## Process the file node. This is where the crazy stuff is to
	## interprete the java code to create magik.
	#
	# Note: the order is important, do not change it
	#
	_self.process_file_top(p_file)
				
	p_file.accept_body_visitor(jpn_try_visitor.new())
	p_file.accept_body_visitor(jpn_andif_orif_visitor.new())
	p_file.accept_body_visitor(jpn_block_if_visitor.new())
	p_file.accept_body_visitor(jpn_loop_while_visitor.new())
	p_file.accept_body_visitor(jpn_iter_visitor.new(p_file))
	p_file.accept_body_visitor(jpn_iter_leave_continue_visitor.new())
	p_file.accept_body_visitor(jpn_catch_builder_visitor.new())
	p_file.accept_body_visitor(jpn_handling_builder_visitor.new())
	p_file.accept_body_visitor(jpn_protection_builder_visitor.new())
	# lock should come after _protection
	p_file.accept_body_visitor(jpn_lock_builder_visitor.new())
	# any unfinised tries are removed now. So All unfinised_try
	# handling should precede.
	p_file.accept_body_visitor(jpn_clean_unfinished_try_visitor.new())
	p_file.accept_body_visitor(jpn_iter_result_hider_visitor.new())
	p_file.accept_body_visitor(jpn_pop_visitor.new())
	p_file.accept_body_visitor(jpn_throw_return_visitor.new())
	p_file.accept_body_visitor(jpn_ignore_environment_building_visitor.new())
	p_file.accept_body_visitor(jpn_ignore_assignment_visitor.new())
	p_file.accept_body_visitor(jpn_cleanup_visitor.new())
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_execution_post_processor.process_file_top(p_file)
	##
	## process the top declarations. Notably the !source_file! and "package".
	##
	_local sts << p_file.body.statements
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop 
		_if i_node.is_dynamic_store? _andif
		    i_node.name = "!source_file!"
		_then
			sts[i_index] << dcn_no_op.new()

			# Share the sourcefile with the file_node.
			p_file.source_file << i_node.value.string_value
			
		_elif i_node.is_dynamic_store? _andif
		      i_node.name = "!current_package!"
		_then
			sts[i_index] << i_node.convert_to_package_declaration()
		_endif
	_endloop

	_if sts.empty?.not
	_then
		_local last << sts.last
		_if last.is_return?
		_then
			_local replace << _if last.expression.is_local?
					  _then >> dcn_no_op.new()
					  _else >> last.expression
					  _endif
			sts[sts.size] << replace
		_endif 
	_endif 
_endmethod
$
