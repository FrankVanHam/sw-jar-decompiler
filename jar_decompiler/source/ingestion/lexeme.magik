_package deco
$

#remex(:lexeme)

_pragma(classify_level=restricted, topic={jar_decompiler})
##
## An item of java input. Lexemes are generated by the java
## lexical scanner and processed by the java_parser.
##
## The lexeme hold the line and column number to aid in debugging.
##
def_slotted_exemplar(:lexeme,
	{
		{:line,   _unset, :readable},
		{:column, _unset, :readable},
		{:type,   _unset},
		{:value,  _unset, :readable} # string|_unset
	})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_eof(p_line, p_column)
	##
	>> _self.new(:eof, _unset, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_comment(p_value, p_line, p_column)
	##
	>> _self.new(:comment, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_annotation(p_value, p_line, p_column)
	##
	>> _self.new(:annotation, p_value, p_line, p_column)
_endmethod

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_keyword(p_value, p_line, p_column)
	##
	>> _self.new(:keyword, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_identifier(p_value, p_line, p_column)
	##
	>> _self.new(:identifier, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_operator(p_value, p_line, p_column)
	##
	>> _self.new(:operator, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_separator(p_value, p_line, p_column)
	##
	>> _self.new(:separator, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_string(p_value, p_line, p_column)
	##
	>> _self.new(:string, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new_number(p_value, p_line, p_column)
	##
	>> _self.new(:number, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.new(p_type, p_value, p_line, p_column)
	## 
	>> _clone.init(p_type, p_value, p_line, p_column)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method lexeme.init(p_type, p_value, p_line, p_column)
	##
	.line << p_line
	.column << p_column
	.type << p_type
	assert(p_value _is _unset _orif p_value.is_class_of?(""))
	.value << p_value
	>> _self 
_endmethod
$

_pragma(classify_level=debug, topic={jar_decompiler})
_method lexeme.debug_type
	>> .type
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_eof?
	>> .type _is :eof
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_comment?
	>> .type _is :comment
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_keyword?
	>> .type _is :keyword
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_identifier?
	>> .type _is :identifier
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_operator?
	>> .type _is :operator
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_separator?
	>> .type _is :separator
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_string?
	>> .type _is :string
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_annotation?
	>> .type _is :annotation	
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_number?
	>> .type _is :number
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_operator?(p_value)
	##
	>> _self.is_operator? _andif .value = p_value
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.is_separator?(p_value)
	##
	>> _self.is_separator? _andif .value = p_value
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.split(p_index)
	##
	_local v1 << .value.slice(1, p_index-1)
	_local v2 << .value.slice_to_end(p_index+1)
	_return _self.new(.type, v1, .line, .column ),_self.new(.type, v2, .line, .column+p_index )
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.append_dotted(p_lex)
	##
	_self.append_string(write_string(".", p_lex.value))
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.append(p_lex)
	##
	_self.append_string(p_lex.value)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method lexeme.append_string(p_string)
	##
	.value << write_string(.value, p_string)
_endmethod
$
