_package deco
$

#remex(:jpn_execution_post_processor)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_execution_post_processor,{})
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_execution_post_processor.process(p_file)
	##
	_self.process_file(p_file)
	
	p_file.accept_body_visitor(jpn_block_andorif_visitor.new())
	p_file.accept_body_visitor(jpn_block_if_visitor.new())
	p_file.accept_body_visitor(jpn_try_visitor.new())
	p_file.accept_body_visitor(jpn_loop_while_visitor.new())
	p_file.accept_body_visitor(jpn_iter_visitor.new(p_file))
	
	p_file.accept_body_visitor(jpn_iter_leave_continue_visitor.new())
	p_file.accept_body_visitor(jpn_catch_builder_visitor.new())
#	_global x
#	x << p_file
#	99.stop
	p_file.accept_body_visitor(jpn_handling_builder_visitor.new())
	p_file.accept_body_visitor(jpn_protection_builder_visitor.new())
	# lock should come after _protection
	p_file.accept_body_visitor(jpn_lock_builder_visitor.new())
	
	# any unfinised tries are removed now. So All unfinised_try
	# handling should precede.
	p_file.accept_body_visitor(jpn_clean_unfinished_try_visitor.new())
	p_file.accept_body_visitor(jpn_iter_result_hider_visitor.new())
	
	p_file.accept_body_visitor(jpn_pop_visitor.new())

	p_file.accept_body_visitor(jpn_throw_return_visitor.new())
	p_file.accept_body_visitor(jpn_ignore_assignment_visitor.new())
	p_file.accept_body_visitor(jpn_cleanup_visitor.new())
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_execution_post_processor.process_file(p_file)
	## 
	sts << p_file.body.statements
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if i_node.is_kind_of?(dcn_dynamic_store) _andif
		    i_node.name = "!source_file!"
		_then
			sts[i_index] << dcn_no_op.new()
		_elif i_node.is_kind_of?(dcn_dynamic_store) _andif
		    i_node.name = "!current_package!"
		_then
			sts[i_index] << dcn_package.new(i_node.sys!slot(:value_node).args[1].string_value)
		_endif 
	_endloop
_endmethod
$
