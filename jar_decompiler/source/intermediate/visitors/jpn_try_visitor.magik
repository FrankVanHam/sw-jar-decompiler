_package deco
$

#remex(:jpn_try_visitor)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_try_visitor,
	{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.new()
	>> _clone.init()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method jpn_try_visitor.init()
	>> _self 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.accept(p_body)
	##
	_local sts << p_body.statements
#	_global x
#	x << sts
#	44.stop
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if _self.is_try?(sts[i_index])
		_then
			sts[i_index] << _self.convert_to_try(sts[i_index])
		_elif _self.is_try_in_try?(i_node)
		_then
			sts[i_index] << _self.convert_to_try_in_try(i_node)
		_endif 
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.convert_to_try_in_try(p_node)
	##
	_local sts << p_node.try_body.statements
	
	_local magik_try << _self.do_convert_to_try(sts)

	_for i _over range(1,5)
	_loop
		sts[sts.size-1-i] << dcn_no_op.new()
	_endloop 
	sts[sts.size-1] << magik_try
	sts[sts.size] << dcn_no_op.new()
	sts[1] << dcn_no_op.new()
	>> p_node
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.convert_to_try(p_node) 
	##
	_local body_sts << p_node.body.statements
	_return _self.do_convert_to_try(body_sts)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method jpn_try_visitor.do_convert_to_try(body_sts)
	_local cond << body_sts[1].name 
	_local sts << body_sts[body_sts.size-1].try_body.statements[1].try_body.statements[2].try_body.statements
	_local idx << 1
	_for i_idx, i_stat _over sts.fast_keys_and_elements()
	_loop
		_if i_stat.is_kind_of?( dcn_call)
		_then
			idx << i_idx+1
			_leave
		_endif
	_endloop  
	_local actual_sts << sts.slice(idx, sts.size-1)

	_local inp << rope.new() 
	_local br << body_sts.last
	_for i_tag, i_cond, i_body _over br.condition_and_bodies()
	_loop
		_if i_tag = :if _orif i_tag = :elif 
		_then
			_local (cond, not?) << _self.extract_condition(i_cond)
			body << _if not?
				_then
					>> dcn_body.new()
				_else
					>> i_body
				_endif 
			inp.add({cond, body})
		_endif
	_endloop
	>> dcn_try.new(cond, dcn_body.new(actual_sts), inp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.extract_condition(p_cond) 
	##
	>> _if p_cond.is_class_of?(dcn_not)
	   _then
		   >> p_cond.expression.args[1].string_value, _true
	   _else
		   >> p_cond.args[1].string_value, _false 
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.is_try?(p_node)
	##
	# deco:x[1].body.statements[8].try_body.statements[1].try_body.statements[1].name

	_if p_node.is_kind_of?(dcn_block).not _then _return _false, :first_block _endif
	_local sts << p_node.body.statements
	_if sts.size < 8 _then _return _false, :not_enough_statements _endif

	_if sts[sts.size-1].is_kind_of?(dcn_unfinished_try).not _then _return _false, :second_last_should_be_unfinished _endif
	_if sts[sts.size-2].is_kind_of?(dcn_dynamic_store).not _then _return _false, :third_last_should_be_dynamic _endif

	_return _true 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.is_try_in_try?(p_node)
	##
	## The java-try block contains the magik-try statements. The
	## java-try will remain because likely it will be a project block
	##
	_if p_node.is_kind_of?(dcn_unfinished_try).not _then _return _false, :no_try _endif
	_local sts << p_node.try_body.statements
	_if sts.size < 8 _then _return _false, :not_enough_statements _endif

	_if sts[sts.size-1].is_kind_of?(dcn_unfinished_try).not _then _return _false, :second_last_should_be_unfinished _endif
	_if sts[sts.size-2].is_kind_of?(dcn_dynamic_store).not _then _return _false, :third_last_should_be_dynamic _endif

	_return _true 
_endmethod
$

