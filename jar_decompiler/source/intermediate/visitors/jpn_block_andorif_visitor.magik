_package deco
$

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_block_andorif_visitor,{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_andorif_visitor.new()
	>> _clone 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_andorif_visitor.accept(p_body)
	##
	_local sts << p_body.statements
	_global y
	y << p_body.statements
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if i_index+2 < sts.size
		_then
			n1 << sts[i_index+0]
			n2 << sts[i_index+1]
			n3 << sts[i_index+2]
			_if _self.is_andif?(n1, n2, n3)
			_then
				sts[i_index+0] << dcn_no_op.new()
				sts[i_index+1] << dcn_no_op.new()
				sts[i_index+2] << _self.convert_to_andif(n1,n2,n3)
			_elif _self.is_orif?(n1, n2, n3)
			_then
				sts[i_index+0] << dcn_no_op.new()
				sts[i_index+1] << dcn_no_op.new()
				sts[i_index+2] << _self.convert_to_orif(n1,n2,n3)
			_endif
		_endif
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_andorif_visitor.is_andif?(n1, n2, n3)
	##
	_if n1.is_class_of?(dcn_local_assignment).not _then _return _false, :no_local_assignment1 _endif
	_if n2.is_class_of?(dcn_branch).not _then _return _false, :no_branch _endif
	_if n3.is_class_of?(dcn_local_assignment).not _then _return _false, :no_local_assignment2 _endif
	
	_local a_local << n1.only_local()
	_if a_local _is _unset _then _return _false, :no_single_local_1 _endif
	_if a_local.object_type <> "Object" _then _return _false, :no_type_object _endif
	_local exp1 << n1.expression
	
	_local local_name << a_local.name
	
	_if n2.just_if?.not _then _return _false, :not_just_only_if _endif
	_local c_loc << n2.if_condition
	_if c_loc.is_class_of?(dcn_local).not _then _return _false, :condition_should_be_local _endif
	_if c_loc.name <> local_name _then _return _false, :condition_should_be_known_name _endif
	_local stats << n2.if_body.statements
	_if stats.size <> 1 _then _return _false, :branch_body_size_should_be_1 _endif
	_local ass << stats[1]
	_if ass.is_kind_of?(dcn_local_assignment).not _then _return _false, :branch_body_is_assign _endif
	_local b_local << ass.only_local()
	_if b_local _is _unset _then _return _false, :branch_body_is_no_local_assign _endif
	_if b_local.name <> local_name _then _return _false, :branch_body_local_name_incorrect _endif
	_local exp2 << ass.expression

	_if n3.only_local() _is _unset _then _return _false, :no_single_local2 _endif 
	_if n3.expression.is_class_of?(dcn_local).not _then _return _false, :expression_should_be_local _endif
	_if n3.expression.name <> local_name _then _return _false, :third_local_name_incorrect _endif
	_return _true 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_andorif_visitor.convert_to_andif(n1, n2, n3)
	##
	_local a_local << n1.only_local()
	_local exp1 << n1.expression
	_local exp2 << n2.if_body.statements[1].expression

	# DEBUG: copy method maken ipv zet expression
	n3.expression << dcn_op.new("_andif", exp1, exp2)
	>> n3
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_andorif_visitor.is_orif?(n1, n2, n3)
	##
	_if n1.is_class_of?(dcn_local_assignment).not _then _return _false, :no_local_assignment1 _endif
	_if n2.is_class_of?(dcn_branch).not _then _return _false, :no_branch _endif
	_if n3.is_class_of?(dcn_local_assignment).not _then _return _false, :no_local_assignment2 _endif
	
	_local a_local << n1.only_local()
	_if a_local _is _unset _then _return _false, :no_single_local_1 _endif
	_if a_local.object_type <> "Object" _then _return _false, :no_type_object _endif
	_local exp1 << n1.expression
	
	_local local_name << a_local.name
	
	_if n2.just_if?.not _then _return _false, :not_just_only_if _endif
	_if n2.if_condition.is_class_of?(dcn_not).not _then _return _false, :condition_should_be_not _endif
	_local c_loc << n2.if_condition.expression
	_if c_loc.is_class_of?(dcn_local).not _then _return _false, :condition_should_be_local _endif
	_if c_loc.name <> local_name _then _return _false, :condition_should_be_known_name _endif
	_local stats << n2.if_body.statements
	_if stats.size <> 1 _then _return _false, :branch_body_size_should_be_1 _endif
	_local ass << stats[1]
	_if ass.is_kind_of?(dcn_local_assignment).not _then _return _false, :branch_body_is_assign _endif
	_local b_local << ass.only_local()
	_if b_local _is _unset _then _return _false, :branch_body_is_no_local_assign _endif
	_if b_local.name <> local_name _then _return _false, :branch_body_local_name_incorrect _endif
	_local exp2 << ass.expression

	_if n3.only_local() _is _unset _then _return _false, :no_single_local2 _endif 
	_if n3.expression.is_class_of?(dcn_local).not _then _return _false, :expression_should_be_local _endif
	_if n3.expression.name <> local_name _then _return _false, :third_local_name_incorrect _endif
	_return _true 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_block_andorif_visitor.convert_to_orif(n1, n2, n3)
	##
	_local a_local << n1.only_local()
	_local exp1 << n1.expression
	_local exp2 << n2.if_body.statements[1].expression

	# DEBUG: copy method maken ipv zet expression
	n3.expression << dcn_op.new("_orif", exp1, exp2)
	>> n3
_endmethod
$
