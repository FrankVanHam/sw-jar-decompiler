_package deco
$

#remex(:jpn_try_visitor)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_try_visitor,
	{})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.new()
	>> _clone.init()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method jpn_try_visitor.init()
	>> _self 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.accept(p_body)
	##
	_local sts << p_body.statements
#	_global x
#	x << sts
#	44.stop
	_for i_index, i_node _over sts.fast_keys_and_elements()
	_loop
		_if _self.is_try?(sts[i_index])
		_then
			sts[i_index] << _self.convert_to_try(sts[i_index])
		_endif 
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.convert_to_try(p_node) 
	##
	_local cond << p_node.body.statements[1].name 
	_local sts << p_node.body.statements[8].try_body.statements[1].try_body.statements[2].try_body.statements
	_local idx << 1
	_for i_idx, i_stat _over sts.fast_keys_and_elements()
	_loop
		_if i_stat.is_kind_of?( dcn_call)
		_then
			idx << i_idx+1
			_leave
		_endif
	_endloop  
	_local actual_sts << sts.slice(idx, sts.size-1)

	_local inp << rope.new() 
	_local br << p_node.body.statements[9]
	_for i_tag, i_cond, i_body _over br.condition_and_bodies()
	_loop
		_if i_tag = :if _orif i_tag = :elif 
		_then
			inp.add({_self.extract_condition(i_cond), i_body})
		_endif
	_endloop
	>> dcn_try.new(cond, dcn_body.new(actual_sts), inp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.extract_condition(p_cond) 
	##
	>> p_cond.args[1].string_value
_endmethod
$



_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_try_visitor.is_try?(p_node)
	##
	# deco:x[1].body.statements[8].try_body.statements[1].try_body.statements[1].name

	_if p_node.is_kind_of?(dcn_block).not _then _return _false, :first_block _endif
	_if p_node.body.statements.size < 8 _then _return _false, :not_enough_statements _endif
	_local sec << p_node.body.statements[2]
	_if sec.is_kind_of?(dcn_local_assignment).not _then _return _false, :no_assignment_on_2 _endif
	
	_local loc << sec.only_local()
	_if loc _is _unset _then _return _false, :no_local _endif
	
	_return loc.name =  "__env__"
_endmethod
$
