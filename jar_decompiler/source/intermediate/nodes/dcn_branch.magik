##
## File            : $File: (dcn_branch.magik) $
## SCM             : $URL$
##
## Copyright       : Realworld Systems
##                   e-mail  : support@realworld-systems.com
##                   address : Venusstraat 17, 4105 JH Culemborg, The Netherlands
##                   tel     : +31(0)345 614406
##                   fax     : +31(0)345 614319
##
## Contains        : 
##
##
## Date written    : 2012-04-05
## Date changed    : $Date$
## Revision        : $Rev$

_package deco
$

remex(:dcn_branch)
$

_pragma(classify_level=restricted, topic={decompiler})
## Node for a branch statement. Branch contains an if and
## optionally and else statement, both with results.
def_slotted_exemplar(:dcn_branch,
		     {
			     {:statements, _unset},
			     {:results, _unset},
			     {:token,_unset},
			     {:end_pc, _unset, :readable},
			     
			     {:else_statements, _unset},
			     {:else_results, _unset},
			     {:else_token,_unset},
			     
			     {:expression, _unset}
		     }, :dcn_base)
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.new(token, expression, statements, results, _optional else_token, else_statements, else_results, end_pc)
	_return _clone.init(token, expression, statements, results, else_token, else_statements, else_results, end_pc)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_branch.init(token, expression, statements, results, _optional else_token, else_statements, else_results, end_pc)
	.token << token
	_if token _is _unset
	_then
		assert( end_pc _isnt _unset, "should have end_pc")
		.end_pc << end_pc
	_else
		.end_pc << token.end_pc
	_endif 
	.statements << rope.deco_check_type(statements)
	.results << rope.deco_check_type(results)
	
	.else_token   << else_token
	.else_statements << rope.deco_check_type(else_statements)
	.else_results    << rope.deco_check_type(else_results)
		
	.expression << expression
	_return _self
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.accept_node_visitor(visitor)
	.expression << .expression.accept_node_visitor(visitor)
	_self.accept_node_visitor_in_vector(visitor, .statements)
	_self.accept_node_visitor_in_vector(visitor, .results)
	_if .else_statements _isnt _unset
	_then 
		_self.accept_node_visitor_in_vector(visitor, .else_statements)
	_endif
	_if .else_results _isnt _unset
	_then 
		_self.accept_node_visitor_in_vector(visitor, .else_results)
	_endif 
	_return _super.accept_node_visitor(visitor)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.accept_body_visitor(visitor)
	.expression.accept_body_visitor(visitor)
	_self.accept_body_visitor_in_vector(visitor, .statements)
	_self.accept_body_visitor_in_vector(visitor, .results)
	_if .else_statements _isnt _unset
	_then 
		_self.accept_body_visitor_in_vector(visitor, .else_statements)
	_endif
	_if .else_results _isnt _unset
	_then 
		_self.accept_body_visitor_in_vector(visitor, .else_results)
	_endif
	
	visitor.visit(_self, .statements)
	_if .else_statements _isnt _unset
	_then 
		visitor.visit(_self, .else_statements)
	_endif 
	_return _super.accept_body_visitor(visitor)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_branch.statements
	_return .statements
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.results
	_return .results
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.has_results?
	
	_return .results.empty?.not
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.is_case_or_branch?
	_return _true
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_branch.try_index
	_return .expression.try_index
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.register_for_try(whens)
	try_index << _self.try_index
	branch_statements << _self.statements
	whens[try_index] << property_list.new_with(
				    :statements, branch_statements,
				    :results, _self.results )
	_return try_index, branch_statements
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_iter _method dcn_branch.branches()
	_loopbody(_self)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.result_count
	c1 << 0
	_for i_res _over .results.fast_elements()
	_loop
		c1 +<< i_res.result_count
	_endloop
	_if .else_results _isnt _unset
	_then
		c2 << 0
		_for i_res _over .else_results.fast_elements()
		_loop
			c2 +<< i_res.result_count
		_endloop
	_else
		c2 << c1
	_endif
	_return c1.max(c2)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.is_hidden_case?
	_return (.else_statements _isnt _unset) _andif
		(
		(
			(.else_statements.size = 1) _andif
				(.else_statements[1].is_case_or_branch?)
		) _orif
		(
			(.else_statements.empty? )_andif
				(.else_results.size = 1) _andif
				(.else_results[1].is_case_or_branch?)
		))
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.as_case()
	_if _self.is_hidden_case?
	_then
		c << dcn_case.new()
		_self.add_to_case(c)
	_else
		c << _unset 
	_endif
	_return c
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.add_to_case(c)
	
	c.add(_self)
	_if _self.is_hidden_case?
	_then
		_if .else_statements.size = 1
		_then 
			b << .else_statements[1]
		_else
			b << .else_results[1]
		_endif 
		.else_statements << _unset
		.else_results << _unset
		.else_token << _unset 
		b.add_to_case(c)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.is_andif?
	
	test? << (.expression _isnt _unset) _andif
		 (.expression.is_test_for_true?  )
	
	_return (.else_statements _is _unset) _andif
		test? _andif 
		.statements.empty? _andif
		_not .results.empty?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.as_andif()
	assert(.results.size = 1)
	sub_ex1 << dcn_op.for_jump_node_negated(.token, .expression)
	sub_ex2 << .results[1]
	_return dcn_op.new(:andif, sub_ex2, sub_ex1)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.is_orif?
	test? << (.expression _isnt _unset) _andif
		 (.expression.is_op?) _andif
		 (.expression.is_not?)
	
	_return (.else_statements _is _unset) _andif
		(.expression _isnt _unset) _andif
		test? _andif 
		.statements.empty? _andif
		_not .results.empty?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.as_orif()
	assert(.results.size = 1)
	_return .expression.new_orif(.results.an_element())
	#_return dcn_op.new(:orif, .results.an_element(), .expression.sys!slot(:operand1))
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.pc
	_return .token.pc
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.has_condition?
	_return .token.has_condition?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.has_forward_jump?
	_return .token.has_forward_jump?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.has_backward_jump?
	_return .token.has_backward_jump?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.decode_then(a_stream)
	a_stream.write("_then")
	a_stream.indent()
	a_stream.newline()
	_self.decode_statements_on(a_stream, .statements)
	_if .results.empty?.not
	_then
		a_stream.write(">> ")
		_self.decode_node_list_on(a_stream, .results)
		a_stream.newline()
	_endif
	a_stream.unindent()
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.decode_else(a_stream)
	_if .else_statements _isnt _unset
	_then
		_self.decode_like_else_on(a_stream)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.decode_on( a_stream, _optional parent, statements )
	a_stream.write( "_if ")
	_self.decode_test_on(a_stream)
	
	a_stream.newline()
	_self.decode_then(a_stream)
	_self.decode_else(a_stream)
	a_stream.write("_endif")
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.decode_test_on(a_stream)
	_if .token _is _unset
	_then
		a_stream.write( "(")
		.expression.decode_on( a_stream )
		a_stream.write( ")")
		_return
	_endif 
	
	_if .token.sys!slot(:is?) _is _true _andif
	    .token.sys!slot(:compare_value) _is _true
	_then
		a_stream.write( "_not (")
		.expression.decode_on( a_stream )
		a_stream.write( ")")
	_else 
		a_stream.write( "(")
		
		_if .token.test_for_false?
		_then
			.expression.decode_on( a_stream )
		_elif .token.test_for_true?
		_then
			a_stream.write( "_not ")
			.expression.decode_on( a_stream )
		_else
			.expression.decode_eval_exp_on( a_stream )
			_if .token.sys!slot(:is?)
			_then
				a_stream.write( " _isnt ")
			_else
				a_stream.write( " _is ")
			_endif
			a_stream.write( "_", .token.sys!slot(:compare_value).write_string.lowercase )
		_endif 
		a_stream.write( ")")
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_branch.decode_like_else_on( a_stream )
	
	a_stream.write( "_else ")
	a_stream.newline()
	a_stream.indent()
	_self.decode_statements_on(a_stream, .else_statements)
	_if .else_results.empty?.not
	_then
		a_stream.write(">> ")
		_self.decode_node_list_on(a_stream, .else_results)
		a_stream.newline()
	_endif
	a_stream.unindent()
_endmethod
$
