_package deco
$

#remex(:dcn_method)
$

_pragma(classify_level=restricted, topic={decompiler})
## Represents a node for a decompiled method from magik.
def_slotted_exemplar( :dcn_method,
		      {
			      {:java_class_name, _unset},
			      {:java_method_name, _unset},
			      {:type, _unset, :readable},
			      {:exemplar_name, _unset, :readable},
			      {:name, _unset, :readable}
		      }, :dcn_callable )
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.new(p_class_name, p_method_name, p_args, p_body, p_type)
	##
	>> _clone.init(p_class_name, p_method_name, p_args, p_body, p_type )
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_method.init(p_class_name, p_method_name, p_args, p_body, p_type )

	assert(p_body.is_kind_of?(dcn_body))
	
	.java_class_name << p_class_name
	.java_method_name << p_method_name
	.type << p_type
	>> _super.init(p_args, p_body)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.method_name
	>> .name.default("no_name_given_in_bind")
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.match_java?(p_class_name, p_method_name)
	##
	>> .java_class_name = p_class_name _andif
		.java_method_name = p_method_name
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.bind_names(p_exemplar_name, p_method_name)
	##
	.exemplar_name << p_exemplar_name
	.name << p_method_name
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.abstract?
	>> _false 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.private?
	>> _false 
_endmethod
$
_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.iter?
	>> _false 
_endmethod
$


#_pragma(classify_level=restricted, topic={decompiler})
### Represents a node for a decompiled method from magik.
#def_slotted_exemplar( :dcn_method,
#		      {
#			      {:method, _unset}
#		      }, :dcn_callable )
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_method dcn_method.new( p_method, statements, locals, literals )
#	_return _clone.init( p_method, statements, locals, literals )
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.init( p_method, statements, locals, literals )
#	.method << p_method
#	.proc << .method.value
#	_return _super.init(p_method.value, statements, locals, literals )
#_endmethod
#$
#
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.exemplar_name
#	_return .method.owner.meta_at(:class_name)
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.method_name
#	_return .method.name
#_endmethod
#$
#
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.iter?
#	_return .method.iter?
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.private?
#	_return .method.private?
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.abstract?
#	_return .method.abstract?
#_endmethod
#$
#

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.magik_exemplar
	##
	_local name << .exemplar_name.as_symbol()
	_for i_pack _over !current_package!.all_packages.fast_elements()
	_loop
		_local glb << i_pack.global_at(name)
		_if glb _isnt _unset
		_then
			_return glb.value
		_endif
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.magik_method
	##
	_local exem << _self.magik_exemplar
	>> _if exem _isnt _unset
	   _then
		   >> exem.method(.name.as_symbol())
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_method.comment
	_local met << _self.magik_method
	>> _if met _isnt _unset
	   _then 
		   >> compiler_info_provider.new().comment_for_method(met)
	   _endif 
_endmethod
$


_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_method.level_topics_and_usages
	_local met << _self.magik_method
	>> _if met _isnt _unset
	   _then 
		   >> compiler_info_provider.new().level_topics_and_usages_for_method(met)
	   _else
		   >> _unset, {}, {}
	   _endif 
_endmethod
$

#
#_pragma(classify_level=restricted, topic={decompiler})
#_method dcn_method.decode_args_on(a_stream)
#	
#	proc << .method.value
#	name << _self.method_name
#	a_stream.write( ".", name.slice( 1, name.size-2))
#	a_stream.write( "(" )
#	_if proc.num_args > 0
#	_then
#		_self.int!decode_args_on(a_stream, 1)
#	_endif 
#	a_stream.write( ")" )
#_endmethod
#$
#
#
##_pragma(classify_level=restricted, topic={decompiler})
##_method dcn_method.last_node_in_method?(node)
##	_return _self.my_last_real_node?(node)
##_endmethod
##$
