_package deco
$

#remex(:dcn_body)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:dcn_body,
	{
		{:statements, _unset, :readable}
	}, :dcn_base)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_body.new()
	>> _clone.init()
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method dcn_body.init()
	##
	.statements << rope.new()
	>> _self 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_body.add(p_node)
	assert(p_node _isnt _unset)
	.statements.add(p_node)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_body.empty?
	>> .statements.empty?
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_body.size
	>> .statements.size
_endmethod
$

#_pragma(classify_level=restricted, topic={jar_decompiler})
#_method dcn_body[x]
#	>> .statements[x]
#_endmethod
#$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_body.decode_on(p_stream)
	##
	_for i_stat _over .statements.fast_elements()
	_loop
		_if i_stat.is_no_op? _then _continue _endif 
		i_stat.decode_on(p_stream)
		p_stream.newline()
	_endloop 
_endmethod
$
