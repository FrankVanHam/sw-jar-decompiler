
_package deco
$

remex(:dcn_proxy_proc)
$

_pragma(classify_level=restricted, topic={decompiler})
## a proxy node for a procedure definition inside a body
## (method/proc). The node will serve as a proxy during the
## compilation of the body until the body is finished. Then the
## proxy will be decompiled too.
def_slotted_exemplar(:dcn_proxy_proc,
		     {
			     {:proc, _unset},
			     {:dcn_proc, _unset},
			     {:imports, _unset},
			     {:sorted_imports, _unset}
		     }, :dcn_base)
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.new(proc)
	_return _clone.init(proc)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_proxy_proc.init(proc)
	.proc << proc
	.dcn_proc << _unset
	.imports << property_list.new()
	.sorted_imports << rope.new()
	_return _self
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.add_import(local,index)
	.imports[index] << local
	.sorted_imports.add_last(local)
#	.sorted_imports.add_first(local)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.decompile()
	.dcn_proc << decompiler.new().decompile_procedure(.proc, .imports, .sorted_imports)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.try_index
	_return .dcn_proc.try_index
_endmethod
$


_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.impl
	assert( .dcn_proc _isnt _unset, "Was not decompiled!")
	_return .dcn_proc
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.decode_on(a_stream, _optional parent, statements)
	_self.impl.decode_on(a_stream)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.result_count
	_return 1
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.as_clone()
	## A proxy_proc is cloned when the proc is stored as a literal
	## and it is subsequently used. The clone will prevent the
	## original proc to be changed. For the decompiler there is
	## sideeffect to the clone will be the same as the original.
	_return _self
_endmethod
$


_pragma(classify_level=restricted, topic={decompiler})
_method dcn_proxy_proc.deco_decode_as_call_on(a_stream, call)
	_if .proc.name = :vec
	_then
		_return call.decode_as_vector_on(a_stream, _self )
	_else
		_return call.decode_as_call_on(a_stream, _self )
	_endif 
_endmethod
$
