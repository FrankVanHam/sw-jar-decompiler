_package deco
$

#remex(:dcn_method)
$

_pragma(classify_level=restricted, topic={decompiler})
## Represents a node for a decompiled method from magik.
def_slotted_exemplar( :dcn_method,
		      {
			      {:java_class_name, _unset},
			      {:java_method_name, _unset},
			      {:type, _unset, :readable},
			      {:exemplar_name, _unset, :readable},
			      {:name, _unset, :readable},
			      {:iter?, _unset, :readable},
			      {:private?, _unset ,:readable},
			      {:abstract?, _unset, :readable}
		      }, :dcn_callable )
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.new(p_class_name, p_method_name, p_args, p_scatter?, p_body, p_type, p_iter?)
	##
	>> _clone.init(p_class_name, p_method_name, p_args, p_scatter?, p_body, p_type, p_iter? )
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_method.init(p_class_name, p_method_name, p_args, p_scatter?, p_body, p_type, p_iter? )

	assert(p_body.is_kind_of?(dcn_body))

	.private? << _false 
	.abstract? << _false
	.iter? << p_iter?
	.java_class_name << p_class_name
	.java_method_name << p_method_name
	.type << p_type
	>> _super.init(p_args, p_scatter?, p_body)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.method_name
	>> .name.default("no_name_given_in_bind")
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.match_java?(p_class_name, p_method_name)
	##
	>> .java_class_name = p_class_name _andif
		.java_method_name = p_method_name
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.bind(p_exemplar_name, p_method_name, p_nr_args, p_mandatory_args, p_private?, p_abstract? )
	##
	.exemplar_name << p_exemplar_name
	.name << p_method_name
	.nr_args << p_nr_args
	.nr_mandatory_args << p_mandatory_args
	.private? << p_private?
	.abstract? << p_abstract?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.abstract?
	>> .abstract? 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.private?
	>> .private?
_endmethod
$


#_pragma(classify_level=restricted, topic={decompiler})
### Represents a node for a decompiled method from magik.
#def_slotted_exemplar( :dcn_method,
#		      {
#			      {:method, _unset}
#		      }, :dcn_callable )
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_method dcn_method.new( p_method, statements, locals, literals )
#	_return _clone.init( p_method, statements, locals, literals )
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.init( p_method, statements, locals, literals )
#	.method << p_method
#	.proc << .method.value
#	_return _super.init(p_method.value, statements, locals, literals )
#_endmethod
#$
#
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.exemplar_name
#	_return .method.owner.meta_at(:class_name)
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.method_name
#	_return .method.name
#_endmethod
#$
#
#
#_pragma(classify_level=restricted, topic={decompiler})
#_private _method dcn_method.iter?
#	_return .method.iter?
#_endmethod
#$
#


_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.magik_exemplar
	##
	_local name << .exemplar_name.as_symbol()
	_for i_pack _over !current_package!.all_packages.fast_elements()
	_loop
		_local glb << i_pack.global_at(name)
		_if glb _isnt _unset
		_then
			_return glb.value
		_endif
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_method.magik_method
	##
	_local exem << _self.magik_exemplar
	>> _if exem _isnt _unset
	   _then
		   _local met << exem.method(.name.as_symbol())
		   >> _if met _isnt _unset _andif
			  met.owner _is exem.define_method_target
		      _then
			      >> met
		      _endif 
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_method.comment
	_local met << _self.magik_method
	>> _if met _isnt _unset
	   _then 
		   >> compiler_info_provider.new().comment_for_method(met)
	   _endif 
_endmethod
$


_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_method.level_topics_and_usages
	_local met << _self.magik_method
	>> _if met _isnt _unset
	   _then 
		   >> compiler_info_provider.new().level_topics_and_usages_for_method(met)
	   _else
		   >> _unset, {}, {}
	   _endif 
_endmethod
$

#
#_pragma(classify_level=restricted, topic={decompiler})
#_method dcn_method.decode_args_on(a_stream)
#	
#	proc << .method.value
#	name << _self.method_name
#	a_stream.write( ".", name.slice( 1, name.size-2))
#	a_stream.write( "(" )
#	_if proc.num_args > 0
#	_then
#		_self.int!decode_args_on(a_stream, 1)
#	_endif 
#	a_stream.write( ")" )
#_endmethod
#$
#
#
##_pragma(classify_level=restricted, topic={decompiler})
##_method dcn_method.last_node_in_method?(node)
##	_return _self.my_last_real_node?(node)
##_endmethod
##$
