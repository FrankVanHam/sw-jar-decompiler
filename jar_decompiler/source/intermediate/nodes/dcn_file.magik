_package deco
$

#remex(:dcn_file)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
## Node for whatever was declared in the file.
def_slotted_exemplar(:dcn_file,
		      {
			      {:java_classes, _unset, :readable},
			      {:statements, _unset,  :readable},
			      {:methods,    _unset,  :readable},
			      {:procs,      _unset,  :readable}
		      },
		      :dcn_base)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.new()
	_return _clone.init( )
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method dcn_file.init()
	.statements << rope.new()
	.methods << rope.new()
	.procs << rope.new()
	.java_classes << rope.new()
	_return _self 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.add_statement(p_node)
	.statements.add(p_node)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.add_java_class(p_class)
	.java_classes.add(p_class)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.add_method(p_method_node)
	##
	.methods.add(p_method_node)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.add_proc(p_proc_node)
	##
	.procs.add(p_proc_node)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.find_class(p_class_name)
	##
	_for i_class _over .java_classes.fast_elements()
	_loop
		_if i_class.matches?(p_class_name)
		_then
			_return i_class
		_endif
	_endloop 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.publish_method(p_class_name, p_java_method_name, p_exemplar_name, p_method_name, p_nr_args, p_nr_mandatory_args, p_abstract?, p_private?)
	##
	## Return the method matches by P_CLASS_NAME,
	## P_JAVA_METHOD_NAME, bound to the given specs.
	
	_local meth << _self.match(.methods, p_class_name, p_java_method_name)
	_if meth _isnt _unset
	_then
		meth.bind(p_exemplar_name, p_method_name, p_nr_args, p_nr_mandatory_args, p_abstract?, p_private?)
	_else
		condition.raise(:error, :string, "cannot find method to bind")
	_endif
	>> meth
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.publish_proc(p_class_name, p_java_method_name, p_proc_name, p_nr_args, p_nr_mandatory_args)
	##
	## Return the proc matches by P_CLASS_NAME,
	## P_JAVA_METHOD_NAME bound to the given specs.

	_local prc << _self.match(.procs, p_class_name, p_java_method_name)
	_if prc _isnt _unset
	_then
		prc.bind(p_proc_name, p_nr_args, p_nr_mandatory_args)
	_else
		condition.raise(:error, :string, "cannot find method to bind")
	_endif
	>> prc
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method dcn_file.match(p_list, p_class_name, p_java_method_name)
	##
	## Return the node matches by P_CLASS_NAME,
	## P_JAVA_METHOD_NAME.
	_for i_method _over p_list.fast_elements()
	_loop
		_if i_method.match_java?(p_class_name, p_java_method_name)
		_then
			_return i_method
		_endif
	_endloop
	_return _unset
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.decode_on(p_stream)
	##
	_for i_statement _over .statements.fast_elements()
	_loop
		_if i_statement.is_no_op? _then _continue _endif 
		i_statement.decode_on(p_stream)
		p_stream.newline()
		p_stream.write("$")
		p_stream.newline()
		p_stream.newline()
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method dcn_file.accept_body_visitor(p_visitor)
	_for i_statement _over .statements.fast_elements()
	_loop
		i_statement.accept_body_visitor(p_visitor)
	_endloop 
_endmethod
$





#
#
#_pragma(classify_level=restricted, topic={jar_decompiler})
#_method dcn_file.accept_node_visitor(visitor)
#	_self.accept_node_visitor_in_vector(visitor, .statements)
#	_return _super.accept_node_visitor(visitor)
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={jar_decompiler})
#_method dcn_file.accept_body_visitor(visitor)
#	_self.accept_body_visitor_in_vector(visitor, .statements)
#	
#	visitor.visit(_self, .statements)
#	_super.accept_body_visitor(visitor)
#_endmethod
#$
#
#_pragma(classify_level=restricted, topic={jar_decompiler})
#_method dcn_file.decode_on(a_stream, _optional parent, statements)
#	a_stream.write( "_block")
#	a_stream.newline()
#	a_stream.indent()
#	_self.decode_statements_on(a_stream, .statements)
#	a_stream.unindent()
#	a_stream.write( "_endblock")
#	a_stream.newline()
#_endmethod
#$
