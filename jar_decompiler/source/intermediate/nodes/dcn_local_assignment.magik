##
## File            : $File: (dcn_local_assignment.magik) $
## SCM             : $URL$
##
## Copyright       : Realworld Systems
##                   e-mail  : support@realworld-systems.com
##                   address : Venusstraat 17, 4105 JH Culemborg, The Netherlands
##                   tel     : +31(0)345 614406
##                   fax     : +31(0)345 614319
##
## Contains        : 
##
##
## Date written    : 2012-04-04
## Date changed    : $Date$
## Revision        : $Rev$

_package deco
$


#remex(:dcn_local_assignment)
$

_pragma(classify_level=restricted, topic={decompiler})
## Node for a single assignment to a local.
def_slotted_exemplar(:dcn_local_assignment,
		     {
			     {:dis_node, _unset},
			     {:local,_unset},
			     {:boot?, _unset},
			     {:expression,_unset},
			     {:must_declare_local?, _unset},
			     {:top_of_stack, _unset}
		     }, {:dcn_base, :dcn_assign_mixin})
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.new(dis_node, boot?, local,expression, top_of_stack)
	_return _clone.init(dis_node, boot?, local, expression, top_of_stack)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_local_assignment.init(dis_node, boot?, local, expression, top_of_stack)
	.dis_node << dis_node
	 .boot? << boot?
	.local << local
	.expression << expression
	.must_declare_local? << _false
	.top_of_stack << top_of_stack
	_return _self
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.is_local_assignment?
	_return _true  
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.accept_node_visitor(visitor)
	.local << .local.accept_node_visitor(visitor)
	.expression << .expression.accept_node_visitor(visitor)
	_return _super.accept_node_visitor(visitor)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.accept_body_visitor(visitor)
	.local.accept_body_visitor(visitor)
	.expression.accept_body_visitor(visitor)
	_return _super.accept_body_visitor(visitor)
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.expression << e
	.expression << e
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.local
	_return .local
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.is_self_assigning_parameter?
	_return (.local _is .expression) _andif
		.local.is_local? _andif 
		.local.parameter?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.is_assign?
	_return _true 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.force_declare_local(loc)
	.must_declare_local? << _true
	.local.force_declare_local()
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.includes_local?(loc)
	_return .local _is loc
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.result_count
	_return 1
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.top_of_stack_during_decompile
	_return .top_of_stack
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.decode_eval_exp_on( a_stream )	
	a_stream.write( "(" )
	_self.decode_on(a_stream)
	a_stream.write( ")" )
	
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.single_assignment?
	_return _true 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.is_single_assign?
	_return _self.single_assignment?
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.single_argument
	_return _self.expression
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.expression
	_return .expression
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.chain_assign_operator?()
	_return _false
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.chain_assign?(value)
	_if value _is _unset _then _return _false _endif
	
	_if _self.expression _is value
	_then
		_return _true
	_else
		_return value.is_chain_assign_for?(_self)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.decode_as_receiver_on( a_stream, _gather a)
	a_stream.write( "(")
	_self.decode_on( a_stream, _scatter a )
	a_stream.write( ")")
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.decode_lhs_on(a_stream)
	.local.decode_on( a_stream )
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.decode_receiver_on( a_stream )
	_self.decode_lhs_on( a_stream )
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.has_rhs?
	_return .expression _isnt _unset 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.decode_rhs_on(a_stream)
	.expression.decode_on( a_stream )
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.decode_on( a_stream, _optional parent, statements)
	_global x
	x << _self 
	_if .local.ignore?
	_then
		.expression.decode_on( a_stream )
		_return 
	_endif 
	local? << .must_declare_local?
	_if local?
	_then
		a_stream.write( "_local ")
	_endif
	ok? << _self.try_decode_combined_assignment(a_stream)
	_if ok? _then _return _endif
	
	par? << .expression.is_send_scatter?
	
	_if par? _then a_stream.write( "(" ) _endif 
	.local.decode_on( a_stream )
	_if par? _then a_stream.write( ")" ) _endif 
	
	_if .boot?
	_then
		a_stream.write( " ^<< " )
	_else 
		a_stream.write( " << " )
	_endif 
	_if par? _then a_stream.write( "(" ) _endif
	.expression.decode_on( a_stream )
	_if par? _then a_stream.write( ")" ) _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={decompiler})
_method dcn_local_assignment.try_decode_combined_assignment(a_stream)
	_if _not .expression.is_op? _then _return _false _endif
	_if .expression.is_combined_assignment?(.local)
	_then
		.expression.decode_combined_assignment(a_stream, .boot?)
		_return _true
	_else
		_return _false
	_endif 
_endmethod
$

