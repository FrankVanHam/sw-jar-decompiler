##
## File            : $File: (dcn_decompile_result.magik) $
## SCM             : $URL$
##
## Copyright       : Realworld Systems
##                   e-mail  : support@realworld-systems.com
##                   address : Venusstraat 17, 4105 JH Culemborg, The Netherlands
##                   tel     : +31(0)345 614406
##                   fax     : +31(0)345 614319
##
## Contains        : 
##
##
## Date written    : 2012-01-26
## Date changed    : $Date$
## Revision        : $Rev$

_package deco
$

remex(:dcn_decompile_result)
$


_pragma(classify_level=restricted, topic={decompiler})
## Base class for the decompiler results that can have pragmas
## and comments.
def_slotted_exemplar(:dcn_decompile_result,
	{
		{:compiler_info, _unset}
	},
	:dcn_base )
$

_pragma(classify_level=restricted, topic={decompiler})
_private _method dcn_decompile_result.init()
	.compiler_info << compiler_info_provider.new()
	_return _self
_endmethod
$


_pragma(classify_level=basic, topic={decompiler})
_abstract _method dcn_decompile_result.comment
	## Return the comment of my target
_endmethod
$

_pragma(classify_level=basic, topic={decompiler})
_private _method dcn_decompile_result.decode_comment_on(a_stream)
	comment << _self.comment
	_if comment _isnt _unset
	_then
		a_stream.write( comment )
		a_stream.newline()
	_endif
_endmethod
$


_pragma(classify_level=basic, topic={decompiler})
_abstract _method dcn_decompile_result.level_topics_and_usages
	## Return the pragma information of my target
_endmethod
$

_pragma(classify_level=basic, topic={decompiler})
_private _method dcn_decompile_result.decode_pragma_on(a_stream)
	(level, topics, usages) << _self.level_topics_and_usages
	
	_if level _isnt _unset _orif
	    topics.empty?.not _orif
	    usages.empty?.not
	_then
		bef? << _false 
		a_stream.write( "_pragma(")
		_if level _isnt _unset
		_then
			a_stream.write( "classify_level=", level)
			def? << _true 
		_endif
		_if topics.empty?.not
		_then
			bef? << _true 
			_if bef? _then a_stream.write( ", ") _endif 
			a_stream.write( "topic={")
			_for topic _over topics.fast_elements()
			_loop
				a_stream.write( topic )
				_if topic _isnt topics.last
				_then
					a_stream.write( ", ")
				_endif 
			_endloop
			a_stream.write( "}")
		_endif 
		_if usages.empty?.not
		_then
			bef? << _true 
			_if bef? _then a_stream.write( ", ") _endif 
			a_stream.write( "usage={")
			_for use _over usages.fast_elements()
			_loop
				a_stream.write( use )
				_if use _isnt usages.last
				_then
					a_stream.write( ", ")
				_endif 
			_endloop
			a_stream.write( "}")
		_endif 
		a_stream.write( ")")
		a_stream.newline()
	_endif
_endmethod
$


_pragma(classify_level=basic, topic={decompiler})
_method dcn_decompile_result.decode_args_on(a_stream, proc, start)
	# normal args
	comma? << _false 
	_for i _over range( start, proc.num_mandatory_args)
	_loop
		_if comma?^<<_true _then a_stream.write( ", ") _endif 
		a_stream.write( proc.basic_arglist[i] )
	_endloop
	# Have optional.
	num_opt << proc.num_args - proc.num_mandatory_args
	_if proc.gather_arg? _then num_opt -<< 1 _endif
	_if num_opt > 0
	_then
		_if proc.num_mandatory_args > start-1
		_then
			a_stream.write( ", ")
		_endif 
		a_stream.write( "_optional ")
		start << proc.num_mandatory_args+1
		end << proc.num_mandatory_args+num_opt
		_for i _over range( start, end )
		_loop
			a_stream.write( proc.basic_arglist[i] )
			_if i <> end
			_then
				a_stream.write( ", ")
			_endif
		_endloop
	_endif 
	_if proc.gather_arg?
	_then
		_if proc.num_mandatory_args > 0 _orif
		    num_opt > 0
		_then
			a_stream.write( ", ")
		_endif 
		
		a_stream.write( "_gather ")
		a_stream.write( proc.basic_arglist.last )
	_endif 
_endmethod
$

