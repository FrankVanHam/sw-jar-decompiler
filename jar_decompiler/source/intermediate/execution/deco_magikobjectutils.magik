_package deco
$

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:deco_magikobjectutils,
	{},
	:deco_execution_base)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_magikobjectutils.createmethod(p_parser,
					   p_exemplar_name, p_method_name,
					   p_class_name, p_java_method_name,
					   p_nr_args, p_nr_mandatory_args,
					   _optional p_x?, p_private?, p_abstract?, p_nr?)
	_local exemplar_name << p_exemplar_name.string_value
	_local method_name << p_method_name.string_value
	_local class_name << p_class_name.string_value
	_local java_method_name << p_java_method_name.string_value

	# strip the .class
	_if class_name.matches?("*.class")
	_then
		class_name << class_name.slice(1, class_name.size-6)
	_endif
	java_method_name << java_method_name.substitute_string("\\","\")

	nr_args << p_nr_args.string_value.as_number()
	nr_mandatory_args << p_nr_mandatory_args.string_value.as_number()

	abstract? << _if p_abstract? _isnt _unset
		     _then >> p_abstract?.string_value = "true"
		     _else >> _false
		     _endif
	private? << _if p_private? _isnt _unset
		     _then >> p_private?.string_value = "true"
		     _else >> _false
		     _endif
	
	_local meth << p_parser.assign_magik_method_names(class_name, java_method_name, exemplar_name, method_name, nr_args, nr_mandatory_args, abstract?, private?)
	>> meth
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_magikobjectutils.should_be_boolean(p_parser, p_expression)
	##
	>> p_parser.parse_expression(p_expression)
_endmethod
$
