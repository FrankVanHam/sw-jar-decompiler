_package deco
$

#remex(:deco_envaccessor)


_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:deco_envaccessor,
	{
		{:var_names, _unset},
		{:cache,     _unset}
	}, :deco_execution_base)
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.init()
	.var_names << equality_property_list.new()
	.cache << equality_property_list.new()
	 >> _self 
_endmethod
$

_block
	deco_envaccessor.init()
_endblock
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.reset()
	.cache.empty()
	.var_names.empty()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.set_var_name(p_index, p_value)
	## 
	.var_names[p_index] << p_value
	.cache.remove_key(p_index)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.bootstrapreseter(p_parser, p_action, p_var, p_env, p_index)
	_if p_action.string_value = "resetEnv"
	_then 
		_local var << p_parser.parse_expression(p_var)
		_local index << p_parser.parse_expression(p_index)

		.cache[index.string_value] << var
	_endif 
	>> dcn_no_op.new()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.bootstrapstorer(p_parser, p_action, p_exp, p_env, p_index)
	_if p_action.string_value = "storeEnv"
	_then
		_local index << p_parser.parse_expression(p_index)
		
		_local exp << p_parser.parse_expression(p_exp)
		.cache[index.string_value] << exp

		_local name << .var_names[index.string_value]
		_if name _isnt _unset
		_then 
			_local left  << dcn_local_declaration.new(name, "Object")
			#_local left_local  << dcn_local.new("Object", name)
			_local right << p_parser.parse_expression(p_exp)
			
			#.cache[index.string_value] << left_local
		
			_return dcn_local_assignment.new(left, right)
		_else
			_return dcn_no_op.new()
		_endif 
	_endif 
	_return dcn_no_op.new()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.bootstrapfetcher(p_parser, p_action, p_env, p_index)
	_if p_action.string_value = "fetchEnv"
	_then 
		_local index << p_parser.parse_expression(p_index)

		_local name << .var_names[index.string_value]
		_local loc << .cache[index.string_value]

		_if name _isnt _unset
		_then
			_return dcn_local.new(0, name)
		_else
			_return loc
		_endif 

#		_if loc _isnt _unset
#		_then
#			_return loc
#		_else
#			_return dcn_local.new(0, name)
#		_endif 
	_else 
		_return dcn_no_op.new()
	_endif 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.save()
	##
	>> property_list.new_with(
		   :var_names, .var_names.copy(),
		   :cache, .cache.copy() )
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method deco_envaccessor.restore(p_props)
	##
	.var_names << p_props[:var_names]
	.cache << p_props[:cache]
_endmethod
$
