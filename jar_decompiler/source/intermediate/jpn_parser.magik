_package deco
$

#remex(:jpn_parser)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:jpn_parser,
	{
		{:top, _unset}
	})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.new()
	##
	>> _clone.init()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method jpn_parser.init()
	##
	#.top << p_jpn_node
	>> _self
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_file(p_top_node)
	##
	.top << dcn_file.new()
	_for i_node _over p_top_node.content.fast_elements()
	_loop
		_local pn << _self.parse_expression(i_node)
		.top.add_statement(pn)
	_endloop
	>> .top
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_statement(p_jnode)
	>> _self.parse_expression(p_jnode)
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_expression(p_node)
	##
	_if p_node.is_class_of?(jpn_cast)
	_then
		_return _self.parse_cast(p_node)
	_elif p_node.is_class_of?(jpn_method_invocation)
	_then
		_if p_node.sender.is_class_of?(jpn_this).not
		_then
			(exec, meth) << _self.executer_and_method_from_node(p_node)
			_return exec.perform(meth, _self, _scatter p_node.args)
		_else
			_return deco_invoker.boot_method(_self, p_node.name, p_node.sender, _scatter p_node.args)
		_endif
	_elif p_node.is_class_of?(jpn_variable)
	_then
		_return _self.parse_variable(p_node)

	_elif p_node.is_class_of?(jpn_constant) _orif
	      p_node.is_class_of?(jpn_type) _orif
	      p_node.is_class_of?(jpn_variable)
	_then
		_if p_node.string_value.includes?(%.).not
		_then
			_return _self.parse_constant(p_node)
		_else
			(exec, meth) << _self.executer_and_method_from_string(p_node.string_value)
			_return exec.perform(meth, _self)
		_endif
	_elif p_node.is_class_of?(jpn_return)
	_then
		_return _self.parse_return_statement(p_node)
	_elif p_node.is_class_of?(jpn_class)
	_then
		_return _self.parse_class(p_node)
	_elif p_node.is_class_of?(jpn_assignment)
	_then
		_return _self.parse_assignment(p_node)
	_elif p_node.is_class_of?(jpn_if)
	_then
		_return _self.parse_branch(p_node)
	_elif p_node.is_class_of?(jpn_body)
	_then
		_return _self.parse_body(p_node)
	_elif p_node.is_class_of?(jpn_variable)
	_then
		_return _self.parse_variable(p_node)
	_elif p_node.is_class_of?(jpn_new)
	_then
		_return _self.parse_new(p_node)
	_elif p_node.is_class_of?(jpn_declaration)
	_then
		_return dcn_no_op.new()
	_elif p_node.is_class_of?(jpn_try)
	_then
		_return _self.parse_body(p_node.try_body)
	_elif p_node.is_class_of?(jpn_this)
	_then
		_return dcn_self.new()
	_else
		_global x
		x << p_node
		debug_print(p_node)

		1.stop
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_branch(p_jnode)
	_local cond_node << _self.parse_expression(p_jnode.condition)
	_local then_body << _self.parse_statement(p_jnode.then)
	_local else_body << _if p_jnode.else _isnt _unset
			    _then >> _self.parse_statement(p_jnode.else)
			    _endif
	>> dcn_branch.new(cond_node, then_body, else_body)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_new(p_jnode)
	##
	>> dcn_new.new(p_jnode)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_constant(p_jnode)
	>> _if p_jnode.string_value = "_self"
	   _then
		   >> dcn_self.new()
	   _else
		   >> _if p_jnode.is_string?
		      _then
			      >> dcn_constant.new_string(p_jnode.string_value)
		      _elif p_jnode.is_number?
		      _then
			      >> dcn_constant.new_number(p_jnode.string_value)
		      _else
			      13.stop
		      _endif
	   _endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_assignment(p_jnode)
	##
	_local left << _self.parse_local(p_jnode.left)
	_local right << _self.parse_expression(p_jnode.right)
	>> dcn_local_assignment.new(_unset, _false, left, right, _unset )
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_variable(p_jnode)
	##
	>> dcn_local.new(1, p_jnode.name, _unset)
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_local(p_jnode)
	##
	>> dcn_local.new(1, p_jnode.name, _unset)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_return_statement(p_jnode)
	##
	_local exp << _self.parse_expression(p_jnode.expression)
	>> dcn_return.new(exp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_class(p_class_node)
	_if p_class_node.implementation = "ExecutableMagik"
	_then
		_self.parse_execution_class(p_class_node)
	_else
		_self.parse_implementation_class(p_class_node)
	_endif
	>> dcn_no_op.new()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_implementation_class(p_class_node)
	_local class_name << p_class_node.name
	_local super_name << p_class_node.implementation
	_for i_meth _over p_class_node.methods.fast_elements()
	_loop
		_local m_node << _self.parse_method(class_name, i_meth)
		.top.add_method(m_node)
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_execution_class(p_class_node)
	_local class_name << p_class_node.name
	_local super_name << p_class_node.implementation

	_for i_meth _over p_class_node.methods.fast_elements()
	_loop
		_if i_meth.type = "TopLevel"
		_then
			_local m_node << _self.parse_method(class_name, i_meth)
			_for i_statement _over m_node.body.statements.fast_elements()
			_loop
				.top.add_statement(i_statement)
			_endloop
		_endif
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_method(p_class_name, p_meth_node)
	##
	_local java_args << p_meth_node.args.copy()
	_if java_args.empty?.not _then java_args.remove_first() _endif

	_local scatter? << _if java_args.empty?.not
			   _then >> java_args.last.varargs?
			   _else >> _false
			   _endif
	_local args << java_args.map(_proc(x) >> x.name _endproc)

	_local body << _self.parse_body(p_meth_node.body)

	_local type << p_meth_node.type
	_local m_node << dcn_method.new(p_class_name, p_meth_node.name, args, scatter?, body, type )
	>> m_node
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_body(p_body_jnode)
	##
	_local b_node << dcn_body.new()
	_for i_jnode _over p_body_jnode.statements.fast_elements()
	_loop
		_local statement_node << _self.parse_expression(i_jnode)
		b_node.add(statement_node)
	_endloop
	>> b_node
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_cast(p_node)
	##
	>> _self.parse_expression(p_node.expression)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.parse_sender(p_expression)
	##
	>> _if p_expression.is_cast?
	   _then >> _self.parse_sender(p_expression.expression)
	   _else >> _self.parse_expression(p_expression)
	   _endif
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.assign_magik_method_names(p_class_name, p_java_method_name, p_exemplar_name, p_method_name, p_nr_args, p_nmandatory_args, p_abstract?, p_private?)
	##
	>> .top.assign_magik_method_names(p_class_name, p_java_method_name, p_exemplar_name, p_method_name, p_nr_args, p_nmandatory_args, p_abstract?, p_private?)
_endmethod
$
_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.executer_and_method_from_string(p_string)

	_local (exec_name, exec_meth_name) <<  (_scatter p_string.split_by(%.))
	_return _self.executer_and_method(exec_name, exec_meth_name)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.executer_and_method_from_node(p_node)
	##
	_local exec << _self.executer_from_node(p_node)

	_local exec_meth_name << p_node.name
	_local exec_meth << write_string(exec_meth_name.lowercase,"()").as_symbol()
	_if exec.method(exec_meth) _is _unset _then condition.raise(:error, :string, write_string("No method ", exec_meth, " for parser execution on ", exec.class_name)) _endif

	>> exec, exec_meth
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.executer_from_node(p_node)
	##
	_if p_node.sender.is_kind_of?(jpn_method_invocation)
	_then
		_local (ex,m) << _self.executer_and_method_from_node(p_node.sender)
		_return ex.perform(m, _self, _scatter p_node.sender.args)
	_else
		_local exec_name << p_node.identifier
		_local global_ex_name << write_string(:deco_ + exec_name.lowercase).as_symbol()
		_local ex << !current_package!.all_packages[:deco][global_ex_name]
		_if ex _is _unset _then condition.raise(:error, :string, write_string("No global for parser execution: ", global_ex_name)) _endif
		_return ex
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method jpn_parser.executer_and_method(exec_name, exec_meth_name)

	_if exec_name _is _unset
	_then
		_return _self, :|exec()|
	_endif

	_local global_ex_name << write_string(:deco_ + exec_name.lowercase).as_symbol()
	_local ex << !current_package!.all_packages[:deco][global_ex_name]
	_if ex _is _unset _then condition.raise(:error, :string, write_string("No global for parser execution: ", global_ex_name)) _endif

	_local exec_meth << write_string(exec_meth_name.lowercase,"()").as_symbol()
	_if ex.method(exec_meth) _is _unset _then condition.raise(:error, :string, write_string("No method ", exec_meth, " for parser execution on ", global_ex_name)) _endif
	>> ex, exec_meth
_endmethod
$
