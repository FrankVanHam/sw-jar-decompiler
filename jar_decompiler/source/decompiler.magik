_package deco
$

#remex(:decompiler)

_pragma(classify_level=restricted, topic={jar_decompiler})
def_slotted_exemplar(:decompiler,
	{
		{:safe?, _unset}
	})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method decompiler.new(_optional p_safe?)
	>> _clone.init(p_safe?)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.init(_optional p_safe?)
	##
	## P_SAFE?: default is _true
	##
	.safe? << p_safe?.default(_true)
	>> _self
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method decompiler.decompile_product(p_product, _optional p_dir)
	##
	_for i_module _over p_product.defined_modules.fast_elements()
	_loop
		_local jar_file << _self.get_jar_file(i_module)
		_if jar_file _isnt _unset
		_then 
			_local dir << _if p_dir _isnt _unset
				      _then
					      >> system.pathname_down(p_dir, i_module.name)
				      _else
					      >> i_module.full_directory
				      _endif 
			_self.decompile_jar_to_dir(jar_file, dir)
		_else
			write("No jar file found for ", i_module)
		_endif 
	_endloop 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method decompiler.decompile_module(p_module, _optional p_dir)
	##
	## Decompile the jar file of the module into magik files. If P_DIR is given,
	## then place the magik files into that directory, otherwise
	## place it into the module directory.

	_local jar_file << _self.get_jar_file(p_module)
	_local dir << p_dir.default(p_module.full_directory)
	_self.decompile_jar_to_dir(jar_file, dir)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.get_jar_file(p_module)
	# sw_core.interaction_components.1.jar
	_local prod << p_module.product
	_local file << write_string(prod.name, ".", p_module.name, ".", p_module.version.default(0), ".jar")

	_for i_dir _over _self.directory_to_root(prod.directory)
	_loop		
		jar_file << system.pathname_down(i_dir, "libs", file)
		
		_if system.file_exists?(jar_file) _then _leave _endif
	_endloop
	_if system.file_exists?(jar_file).not 
	_then
		write(write_string("The module jar file ", file, " does not exist."))
	_endif
	>> jar_file	
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _iter _method decompiler.directory_to_root(p_dir)
	##
	_local dir << p_dir 
	_loop
		_loopbody(dir)

		_local upper << system.pathname_up(dir)

		_if (upper = dir) _orif (upper _is _unset) _then _leave _endif
		
		dir << upper
	_endloop 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_method decompiler.decompile_jar_dir_to_dir(p_search_dir, p_match, p_dir)
	_local ch << directory_channel.new(p_search_dir, p_match)
	_loop
		_local path << ch.get_full()
		_if path _is _unset _then _leave _endif

		write("Decompiling: ", path)
		_self.decompile_jar_to_dir(path, p_dir)
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method decompiler.decompile_jar_to_dir(p_jar_file, p_dir)
	##
	_if .safe?
	_then
		_try
			_handling error _with _self.report_error_proc
			
			_self.int!decompile_jar_to_dir(p_jar_file, p_dir)
		_when error
			
		_endtry 
	_else
		_self.int!decompile_jar_to_dir(p_jar_file, p_dir)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method decompiler.int!decompile_jar_to_dir(p_jar_file, p_dir)
	##
	_local inp << _self.get_java_decompiler_stream(p_jar_file)
	_protect 
		_local s << deco:lexical_scanner.new(inp)
		_local p << deco:java_parser.new(s)
		_local jpn_jar << p.parse_file()
		
		_local jp << deco:jpn_parser.new()
		_local dcn_jar << jp.parse_file(jpn_jar)
		deco:jpn_execution_post_processor.process_jar(dcn_jar)
		
		_for i_file _over dcn_jar.files.fast_elements()
		_loop
			_if i_file.empty? _then _continue _endif
			_self.write_magik_file(p_dir, i_file)
		_endloop
	_protection
		inp.close()
	_endprotect 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.report_error_proc
	>> _proc(p_condition)
		   p_condition.report_contents_on(!output!)
		   !traceback!(!output!)
	   _endproc 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.com_gesmallworld_magik_jars
	##
	_local jars << rope.new()
	_local dir << smallworld_product.product_path
	dir << system.pathname_down(dir, "libs")
	
	_local names << {"com.gesmallworld.magik.runtime", "com.gesmallworld.magik.commons"}
	_local channel << directory_channel.new(dir)
	_loop
		_local str << channel.get_full()
		_if str _is _unset _then _leave _endif
		
		_for i_name _over names.fast_elements()
		_loop
			_if str.matches?(write_string("*", i_name, "*"))
			_then
				jars.add(str)
			_endif 
		_endloop 
	_endloop
	>> jars
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.classpath
	##
	_local classpath << internal_text_output_stream.new()
	classpath.write(%")
	classpath.write(smallworld_product.get_java_file("cfr-0.151.jar",:jar_decompiler))
	classpath.write(%;)
	_for i_fname _over _self.com_gesmallworld_magik_jars.fast_elements()
	_loop
		classpath.write(i_fname)
		classpath.write(%;)
	_endloop 
	classpath.write(%")
	>> classpath.string
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.get_java_decompiler_stream(p_jar_file)
	## 
	 _local command << rope.new()
	command.add("java")
	command.add("-classpath")
	command.add(_self.classpath)
	command.add("org.benf.cfr.reader.Main")
	command.add(write_string(%", p_jar_file, %"))
	_local (inp, pid) << system.input_from_command(command)
	>> inp
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.write_magik_file(p_dir, p_file_node)
	##
	_local file << system.pathname_down(p_dir, p_file_node.get_file_name())

	(x, dir) << system.pathname_components(file)
	_self.ensure_directory(dir)
	_self.ensure_writable(file)
	
	 _local out_ind << indentation_stream.new(out << internal_text_output_stream.new())
	p_file_node.decode_on(out_ind)
	
	_local out_file << external_text_output_stream.new(file)
	_protect
		write("writing: ", file)
		out_file.write(out.string)
	_protection
		out_file.close()
	_endprotect 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.ensure_directory(p_dir)
	_if _not system.file_exists?(p_dir)
	_then 
		system.mkdir_tree(p_dir)
		_if _not system.file_exists?(p_dir)
		_then
		condition.raise(:error, :string, write_string("The diretory ", p_dir, " is not creatable"))	
		_endif 
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method decompiler.ensure_writable(p_file)
	_if system.file_creatable?(p_file).not
	_then
		condition.raise(:error, :string, write_string("The file ", p_file, " is not writable"))
	_endif 
_endmethod
$
