_package deco
$
#remex(:java_parser)

_pragma(classify_level=advanced, topic={jar_decompiler})
##
## A parser for java that takes in a java_scanner and build jpn
## parse nodes.
## the main method is parse_file()
#
# By no means a complete (or good) java parser, but enough for the
# java code that is generated for Magik.
#
def_slotted_exemplar(:java_parser,
	{
		{:context,         _unset},
		{:scanner,         _unset},
		{:end_value_stack, _unset},
		{:operator_stack,  _unset}
	})
$

_pragma(classify_level=restricted, topic={jar_decompiler})
##
## internal keywords that could represent a type.
##
java_parser.define_shared_constant(:internal_types,
	equality_set.new_with("boolean","double","byte","int","short","var","long","float","void"),
	:private)
$

_pragma(classify_level=restricted, topic={jar_decompiler})
##
## internal keywords that could represent a type.
##
java_parser.define_shared_constant(:internal_constants,
	equality_set.new_with("true", "false", "null"),
	:private)
$

_pragma(classify_level=advanced, topic={jar_decompiler})
_method java_parser.new(p_scanner)
	>> _clone.init(p_scanner)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.init(p_scanner)
	.scanner << peekable_input_stream.new(p_scanner)
	.context <<  java_context.new()
	.context.add("__env__")
	.end_value_stack << stack.new_with(_unset)
	.operator_stack << stack.new_with(_unset)
	>> _self
_endmethod
$

_pragma(classify_level=debug, topic={jar_decompiler})
_method java_parser.define_locals(_gather p_names)
	##
	## Fake the availability of the names locals. Used for unit tests.
	##
	.context.add_all(p_names)
_endmethod
$

_pragma(classify_level=advanced, topic={jar_decompiler})
_method java_parser.parse_file()
	##
	## parse the scanner as a jpn_jar node
	##
	_local f << jpn_jar.new()
	_loop
		_local node << _self.get()
		_if node _is _unset _then _leave _endif

		f.add(node)
	_endloop
	>> f
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method java_parser.get()
	##
	## Get the main object: package, import or class.
	##
	_local anns << _self.parse_annotations()
	_local lex << .scanner.peek()
	_if lex.is_keyword?
	_then
		_if lex.value = "package"
		_then
			_return _self.parse_package()
		_elif lex.value = "import"
		_then
			_return _self.parse_import()
		_elif lex.value = "public"
		_then
			_return _self.parse_class(anns)
		_else
			condition.raise(:deco_unexpected_keyword, :line, lex.line, :column, lex.column, :keyword, lex.name)
		_endif
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_annotations()
	##
	## Parse Java annotations; typcally before a class or method
	## definition that contains important meta data.
	_local ans << rope.new()
	_loop 
		_local lex << .scanner.peek()
		_if lex.is_annotation?
		_then
			ans.add(_self.parse_annotation())
		_else
			_leave
		_endif
	_endloop 
	>> ans
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_annotation()
	##
	_local name << .scanner.get()
	_local lex  << .scanner.peek()
	_if lex.is_separator?("(")
	_then
		props << _self.parse_annotation_properties()
	_else
		props << _unset
	_endif 
	>> jpn_annotation.new(name, props)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_annotation_properties()
	##
	## Parse annotation like: @Debugger(value="MagikDebug")
	##
	_local props << property_list.new()
	_self.ensure_separator("(")
	_loop
		_local lex << .scanner.peek()
		_if lex.is_separator?(")") _then _leave _endif
		_if lex.is_separator?(",")
		_then
			.scanner.get()
		_endif
		
		_local key << .scanner.get()
		_self.ensure_operator("=")
		lex << .scanner.peek()
		_if lex.is_separator?("{")
		_then
			value << _self.parse_annotation_list_of_properties()
		_else 
			value << _self.parse_expression()
		_endif
		props[key.value.as_symbol()] << value 
	_endloop
	
	_self.ensure_separator(")")
	>> props
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_annotation_list_of_properties()
	##
	## Parse annotation properties, like:
	## @EnvVars(value={@EnvVar(name="__dynamic_frame__", type=Object.class, start=21, end=53, index=0), @EnvVar(name="_self", type=Object.class, start=13, end=54, index=1)})
	##
	list << rope.new()
	_self.ensure_separator("{")
	_loop
		_local lex << .scanner.peek()
		_if lex.is_separator?("}") _then _leave _endif
		_if lex.is_separator?(",")
		_then
			.scanner.get()
		_endif
		list.add(_self.parse_annotation())
	_endloop
	_self.ensure_separator("}")
	>> list		
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_class(_optional p_annotations)
	##
	_self.ensure_keyword("public")
	_self.ensure_keyword("class")
	_local name_lex << .scanner.get()
	_local lex      << .scanner.peek()
	_if lex.is_keyword? _andif lex.value = "implements"
	_then
		.scanner.get()
		parent << .scanner.get()
	_else
		parent << _unset
	_endif
	_self.ensure_separator("{")
	_local methods << _self.parse_class_methods(name_lex.value)
	_self.ensure_separator("}")
	
	_return jpn_class.new(name_lex, parent, methods, p_annotations )
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_class_methods(p_name)
	## 
	 _local methods << rope.new()
	_loop
		_local next << .scanner.peek()
		_if next.is_separator? _then _leave _endif
		_if next.is_eof?       _then _leave _endif

		_local annotations << _self.parse_annotations()
		_local meth        << _self.parse_method(p_name, annotations)
		
		methods.add(meth)
	_endloop
	>> methods
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method java_parser.parse_method(p_class_name, _optional p_annotations )
	##
	.context << .context.push()
	
	_self.optional_keyword("public")
	_self.optional_keyword("static")
	_local type_or_name_lex << .scanner.get()
	
	_if type_or_name_lex.value = p_class_name
	_then
		# constructor
		type << _unset
		name << type_or_name_lex
	_else
		# normal method
		type << type_or_name_lex
		name << .scanner.get()
	_endif
	
	_local lex << .scanner.peek()
	_self.ensure_separator("(")
	_local args << _self.parse_parameters()
	_self.ensure_separator(")")
	
	_self.ensure_separator("{")
	_local body << _self.parse_body(args)
	_self.ensure_separator("}")
	.context << .context.pop()
	
	_return jpn_method.new(name, args, body, p_annotations)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_parameters()
	##
	## Parse invocation of parameters
	## e.g: (Object[] __env__, Object i_index, Object ... i_var)
	##
	_local params << rope.new()
	_loop
		_local varargs? << _false 
		_local lex << .scanner.peek()
		_if lex.is_separator?
		_then
			_if lex.value = ")"
			_then
				_leave
			_elif lex.value = ","
			_then
				.scanner.get()
			_else
				condition.raise(:deco_unexpected_separator, :line, lex.line, :column, lex.column, :separator, lex.name)
			_endif
		_endif
		_local type << _self.parse_type_declaration()
				
		lex << .scanner.peek()
		_if lex.is_separator?("...")
		_then
			.scanner.get()
			varargs? << _true
		_endif 
				
		_local identifier << .scanner.get()
		params.add(jpn_parameter.new(identifier, type, varargs?))
	_endloop
	>> params
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_type_declaration()
	##
	## Parse type like: Object, ContinueCatcher.Continue, Object[]
	##
	_local name << .scanner.get()
	_local type << jpn_type.new(name)
	_loop 
		_local lex << .scanner.peek()
		_if lex.is_separator?("[")
		_then
			_self.ensure_separator("[")
			_self.ensure_separator("]")
			type << jpn_type.new(name, _true)
			_leave 
		_elif lex.is_separator?(".")
		_then
			.scanner.get()
			_local ident << .scanner.get()
			type << type.become_dotted(ident)
		_else
			_leave 				
		_endif 
	_endloop
	>> type
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_body(_optional p_params)
	.context << .context.push()
	.context.add_all(p_params.default({}).map(_proc(x) >> x.name _endproc))
	_local stats << rope.new()
	_loop
		_local lex << .scanner.peek()
		_if lex.is_separator?
		_then
			_if lex.value = "}"   # eof body
			_then
				_leave
			_elif lex.value = ";" # eof statements
			_then
				.scanner.get()
			_else
				stats.add(_self.parse_statement())
			_endif
		_else
			stats.add(_self.parse_statement())
		_endif
	_endloop
	.context << .context.pop()
	>> jpn_body.new(stats)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method java_parser.parse_statement()
	##
	_local lex << .scanner.peek()
	_local lex2 << .scanner.peek(2)

	_if (lex.is_identifier? _orif lex.is_keyword?) _andif (lex2.value = "=")
	_then
		# keywords can be identifiers to (like switch=1), so get them first
		_local ident << _self.parse_identifier_or_type()
		_return _self.parse_assignment(ident)
		
	_elif lex.value = "return"
	_then
		_return _self.parse_return_statement()
	_elif lex.value = "if"
	_then
		_return _self.parse_if()
	_elif lex.value = "break"
	_then
		_return _self.parse_break()
	_elif lex.value = "continue"
	_then
		_return _self.parse_continue()
	_elif lex.value = "try"
	_then
		_return _self.parse_try()
	_elif lex.value = "finally"
	_then
		_return _self.parse_finally()
	_elif lex.value = "catch"
	_then
		_return _self.parse_catch()
	_elif lex.value = "synchronized"
	_then
		_return _self.parse_synchronized()
	_elif lex.value = "throw"
	_then
		_return _self.parse_throw()
	_elif lex.value = "lbl"
	_then
		_return _self.parse_lbl_block()
	_elif lex.value = "while"
	_then
		_return _self.parse_loop()
	_elif lex.value = "do"
	_then
		_return _self.parse_while_loop()

	_elif _self.serves_as_identifier?(lex)
	_then
		_local ident << _self.parse_identifier_or_type()
		_local next  << .scanner.peek()
		
		_if next.is_operator?("=")
		_then
			# e.g.: x = 10;
			_return _self.parse_assignment(ident)
			
		_elif _self.serves_as_identifier?(next)
		_then
			# e.g.: int x = 10;
			# or
			# int x;
			_return _self.parse_typed_declaration(ident)
		_else
			# no assignment, so continue parsing expression
			_return _self.parse_expression_starting(ident)
		_endif
	_else
		_return _self.parse_expression()
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_return_statement()
	##
	.scanner.get()
	_local exp << _self.parse_expression()
	_return jpn_return.new(exp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_method java_parser.parse_expression()
	##
	## parse a wide range of expressions. Optional a starting
	## expression P_EXP can be given.
	##
	# is invoked in recursion.
	#
	_local exp << _self.parse_sub_expression()
	>> _self.parse_expression_starting(exp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_expression_starting(p_exp)
	##
	## 
	_local stop_value       << .end_value_stack.first  # a end_value could have been provided
	_local current_operator << .operator_stack.first   # we might be processing an operator

	# build-up exp in recursion
	_local exp << p_exp
	_loop
		_local lex << .scanner.peek()
		
		_if (stop_value _isnt _unset) _andif (lex.value = stop_value)
		_then
			_return exp
		_endif 
		
		_if lex.is_separator?(".")
		_then
			exp << _self.parse_dot(exp)
		
		_elif lex.is_operator?("?")
		_then
			# test operator order
			_if _self.operator_cf?(current_operator, "?")
			_then
				_return exp
			_endif
			exp << _self.parse_condition(exp)
				
		_elif lex.is_operator?("!=") _orif
		      lex.is_operator?("==") _orif
		      lex.is_operator?("||") _orif
		      lex.is_operator?("&&")
		_then
			# test operator order
			_if _self.operator_cf?(current_operator, lex.value)
			_then
				_return exp
			_endif
			exp << _self.parse_test(exp)
			
		_elif lex.is_operator?(":")
		_then
			_return _self.parse_block(exp)

		_elif lex.is_separator?("(")
		_then
			exp << _self.parse_execution_parenthesis(exp)
			
		_elif lex.is_eof? _orif
		      lex.is_separator? 
		_then
			_leave 
		_elif exp.is_parenthesis?
		_then
			exp << _self.parse_cast(exp)
		_else
			_leave 
		_endif
	_endloop
	>> exp
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_execution_parenthesis(p_exp)
	##
	## Either we are casting or invoking a method.
	>> _if p_exp.is_parenthesis?
	   _then
		   >> _self.parse_cast(p_exp)
	   _else
		   _local (sender, meth) << p_exp.split_in_identifier_and_method()
		   >> _self.parse_method_invocation(sender, meth)
	   _endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_dot(exp)
	##
	.scanner.get()
	_local ident << .scanner.get()
	>> exp.become_dotted(ident)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_expression_until(p_end)
	##
	.end_value_stack.push(p_end)
	_local exp << _self.parse_expression()
	.end_value_stack.pop()
	>> exp
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_sub_expression()
	_local lex << .scanner.peek()
	
	_if lex.is_separator?(";") _orif lex.is_eof?
	_then
		_return _unset
	_elif lex.is_separator?("(")
	_then
		_return _self.parse_parenthesis()
	_elif lex.is_operator?("!")
	_then
		_return _self.parse_not()
	_elif lex.is_operator?("?")
	_then
		# this ? is an unknown identifier, like in: (Class<?>)a_var
		_return _self.parse_identifier()
	_elif lex.is_operator?("-")
	_then
		_return _self.parse_negative()
		
	_elif lex.is_identifier? _andif _self.internal_constants.includes?(lex.value)
	_then
		_return jpn_constant.new(.scanner.get())
	_elif lex.is_string?
	_then
		_return jpn_constant.new(.scanner.get())
	_elif lex.is_number?
	_then
		_return jpn_constant.new(.scanner.get())
	_elif _self.serves_as_identifier?(lex)
	_then
		_local ident << _self.parse_identifier_or_type()
		_local next << .scanner.peek()
		
		_if next.is_operator?("=")
		_then
			_return _self.parse_assignment(ident)			
		_else
			_return ident
		_endif
	_elif lex.is_keyword?
	_then
		_if lex.value = "new"
		_then
			_return _self.parse_new()
		_else
			_return _self.parse_type_identifier()
		_endif
	_elif lex.value = "*"
	_then
		_self.eat_till(";", "{", "}")
		_return jpn_failed.new()
	_else
		condition.raise(:deco_unexpected_token, :line, lex.line, :column, lex.column, :token, lex.value)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.eat_till(_gather p_ends)
	##
	_local s << equality_set.new_from(p_ends)
	_for i _over range(1,100)
	_loop
		_local lex << .scanner.peek()
		_if s.includes?(lex.value) _orif lex.is_eof? _then _leave _endif

		.scanner.get()
	_endloop
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.serves_as_identifier?(p_lex)
	## 
	## Answer if P_LEX could service as an identifier in the Java language.	
	>> p_lex.is_identifier? _orif
		_self.internal_types.includes?(p_lex.value)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_loop(_optional p_tag)
	##
	_self.ensure_keyword("while")
	_self.ensure_separator("(")
	_local cond << _self.parse_expression()
	_self.ensure_separator(")")
	
	_local lex << .scanner.peek()
	_if lex.value = "lbl"
	_then
		_self.eat_till(";", "}", "{")
	_endif
	_self.ensure_separator("{")
	_local body << _self.parse_body()
	_self.ensure_separator("}")
	>> jpn_loop.new(body, _true, cond, p_tag)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_while_loop(_optional p_tag)
	##
	_self.ensure_keyword("do")
	_self.ensure_separator("{")
	_local body << _self.parse_body()
	_self.ensure_separator("}")
	_self.ensure_keyword("while")
	_self.ensure_separator("(")
	_local exp << _self.parse_expression()
	_self.ensure_separator(")")
	>> jpn_loop.new(body, _false, exp, p_tag)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.is_variable?(p_name)
	##
	>> .context.includes?(p_name)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_identifier_or_type()
	##
	_local lex << .scanner.peek()
	>> _if _self.is_variable?(lex.value)
	   _then
		   >> _self.parse_identifier()
	   _else
		   >> _self.parse_type_identifier()
	   _endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_identifier()
	## 
	_local ident_lex << .scanner.get()
	_local ident << jpn_variable.new(ident_lex)
	
	_local next << .scanner.peek()
	_if next.is_separator?("[")
	_then
		ident << _self.parse_array_invocation(ident_lex)
	_elif next.is_operator?("<")
	_then
		# parse the args and ignore them.
		_self.parse_args("<",">")
	_endif
	>> ident
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_type_identifier()
	##
	_local ident 
	_local ident_lex << .scanner.get()
	_local next_lex  << .scanner.peek()
	_if next_lex.is_separator?("[")
	_then
		ident << _self.parse_array_type(ident_lex)
	_else
		ident << jpn_type.new(ident_lex)
		_if next_lex.is_operator?("<")
		_then
			# parse the args and ignore them.
			_self.parse_args("<",">")
		_endif
	_endif 
	>> ident
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_array_invocation(p_lex)
	##
	_local args << _self.parse_args("[","]")
	>> jpn_array_access.new(p_lex, args)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_array_type(p_name)
	##
	_self.ensure_separator("[")
	_self.ensure_separator("]")
	_return jpn_type.new(p_name, _true)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_lbl_block()
	##
	_self.ensure_identifier("lbl")
	_self.ensure_operator("-")
	.scanner.get()
	_self.ensure_operator(":")
	_self.ensure_separator("{")
	_local body << _self.parse_body()
	_self.ensure_separator("}")
	>> jpn_failed.new()
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_synchronized()
	## 
	_self.ensure_keyword("synchronized")
	_self.ensure_separator("(")	
	_local exp << _self.parse_expression()
	_self.ensure_separator(")")
	_self.ensure_separator("{")
	_local body << _self.parse_body()
	_self.ensure_separator("}")	
	>> jpn_synchronized.new(exp, body)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_throw()
	## 
	_self.ensure_keyword("throw")
	_local exp << _self.parse_expression()
	>> jpn_throw.new(exp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_break()
	## 
	_self.ensure_keyword("break")
	_local lex << .scanner.peek()
	>> _if lex.is_identifier?
	   _then 
		   >> jpn_break.new(.scanner.get())
	   _else
		   >> jpn_break.new()
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_continue()
	## 
	_self.ensure_keyword("continue")
	_local lex << .scanner.peek()
	>> _if lex.is_identifier?
	   _then
		   >> jpn_continue.new(.scanner.get())
	   _else
		   >> jpn_continue.new()
	   _endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_new()
	## 
	_self.ensure_keyword("new")
	_local array? << _false 
	_local type << .scanner.get()
	_local lex  << .scanner.peek()
	_if lex.is_separator?("(")
	_then 
		args << _self.parse_args("(",")")
	_elif lex.is_separator?("[")
	_then
		args << _self.parse_array_args()
		array? << _true
		lex << .scanner.peek()
		_if lex.is_separator?("{")
		_then
			args << _self.parse_args("{","}")
		_endif 
	_else
		condition.raise(:deco_unexpected_token, :line, lex.line, :column, lex.column, :token, lex.value)
	_endif 
	>> jpn_new.new(type, args, array?)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_try()
	##
	_self.ensure_keyword("try")
	
	_self.ensure_separator("{")
	_local try_body << _self.parse_body()
	_self.ensure_separator("}")

	_local lex << .scanner.peek()
	_if lex.is_keyword?("finally")
	_then
		_self.ensure_keyword("finally")
		_self.ensure_separator("{")
		finally_body << _self.parse_body()
		_self.ensure_separator("}")
	_else
		finally_body << jpn_body.new()
	_endif 
	lex << .scanner.peek()
	_if lex.is_keyword?("catch")
	_then
		_self.ensure_keyword("catch")
		_self.ensure_separator("(")
		catch_args << _self.parse_parameters()
		_self.ensure_separator(")")
		_self.ensure_separator("{")
		catch_body << _self.parse_body(catch_args)
		_self.ensure_separator("}")
	_else
		catch_args << {}
		catch_body << jpn_body.new()
	_endif
	lex << .scanner.peek()
	_if lex.is_separator?("{")
	_then
		# some nonsense can come behind the try() block.
		_self.ensure_separator("{")
		_self.parse_body()
		_self.ensure_separator("}")
	_endif 
	>> jpn_try.new(try_body, catch_args, catch_body, finally_body)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_catch()
	##
	_self.ensure_keyword("catch")
	_self.ensure_separator("(")
	catch_args << _self.parse_parameters()
	_self.ensure_separator(")")
	_self.ensure_separator("{")
	catch_body << _self.parse_body(catch_args)
	_self.ensure_separator("}")
	>> jpn_body.new()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_finally()
	## 
	_self.ensure_keyword("finally")
	_self.ensure_separator("{")
	_local finally_body << _self.parse_body()
	_self.ensure_separator("}")
	>> jpn_body.new()
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_if()
	##
	_self.ensure_keyword("if")
	_self.ensure_separator("(")
	_local condition << _self.parse_expression()
	_self.ensure_separator(")")

	_local lex << .scanner.peek()
	_if lex.is_separator?("{")
	_then 
		_self.ensure_separator("{")
		then_body << _self.parse_body()
		_self.ensure_separator("}")
	_else
		_local stat << _self.parse_statement()
		then_body << jpn_body.new(rope.new_with(stat))
	_endif 

	_local input << rope.new_with( {condition, then_body} )
	_loop
		_local node << .scanner.peek()
		_if node.is_keyword? _andif node.value = "else"
		_then
			.scanner.get()
			node << .scanner.peek()
			_if node.is_keyword? _andif node.value = "if"
			_then
				.scanner.get()
				_self.ensure_separator("(")
				condition << _self.parse_expression()
				_self.ensure_separator(")")
			_else
				condition << _unset
			_endif 
			_self.ensure_separator("{")
			body << _self.parse_body()
			_self.ensure_separator("}")
			
			input.add({condition, body})
		_else
			_leave 
		_endif
	_endloop 
	>> jpn_if.new(input)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_assignment(p_left)
	##
	_self.ensure_operator("=")
	_local right << _self.parse_expression()
	>> jpn_assignment.new(p_left, right)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_test(p_left)
	##
	_local op << .scanner.get()
	.operator_stack.push(op.value)
	_local right << _self.parse_expression()
	.operator_stack.pop()
	>> jpn_operation.new(p_left, right, op)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_condition(p_condition)
	##
	## parse ? condition x = a ? b : c
	##
	.operator_stack.push("?")
	.scanner.get()
	_local then << _self.parse_expression_until(":")
	_local return_then << jpn_soft_return.new(then)
	_local then_body << jpn_body.new({return_then})
	_self.ensure_operator(":")
	_local else << _self.parse_expression()
	_local return_else << jpn_soft_return.new(else)
	_local else_body << jpn_body.new({return_else})
	.operator_stack.pop()
	>> jpn_if.new({{p_condition, then_body}, {_unset, else_body}})
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.operator_cf?(p_op1, p_op2)
	##
	## Does operator P_OP1 comes for P_OP2?
	##
	_if p_op1 _is _unset _then _return _false _endif
	
	_local _constant order << {"!=", "==", "&&", "||", "?"}
	>> order.index_equal_of(p_op1) < order.index_equal_of(p_op2)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_block(p_ident)
	##
	_self.ensure_operator(":")
	_local lex << .scanner.peek()
	_if lex.is_keyword?("while")
	_then
		_return _self.parse_loop(p_ident)
	_elif lex.is_separator?("{")
	_then 
		_self.ensure_separator("{")
		_local body << _self.parse_body()
		_self.ensure_separator("}")
		_return jpn_block.new(p_ident, body)
	_else
		_return jpn_label.new(p_ident)
	_endif 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_typed_declaration(p_type)
	##
	## could be assignment too.
	##
	_local ident << .scanner.get()
	.context.add(ident.value)
	
	_local left << jpn_declaration.new(p_type,ident)
	_local next_lex << .scanner.peek()
	_if next_lex.is_operator?("=")
	_then 
		_self.ensure_operator("=")
		_local right << _self.parse_expression()
		_return jpn_assignment.new(left, right)
	_else
		_return left
	_endif 
_endmethod
$


_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_parenthesis()
	##
	_self.ensure_separator("(")
	.operator_stack.push(_unset) # forget about the current operator
	
	_local type << _self.parse_expression_until(")")
	
	.operator_stack.pop()
	_self.ensure_separator(")")
	_return jpn_parenthesis.new(type)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_not()
	##
	_self.ensure_operator("!")
	_local exp << _self.parse_expression()
	>> jpn_not.new(exp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_negative()
	##
	_self.ensure_operator("-")
	_local exp << _self.parse_expression()
	>> jpn_negated.new(exp)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_cast(p_parenthesis)
	##
	_local value << _self.parse_expression()
	>> jpn_cast.new(p_parenthesis.expression, value)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_method_invocation(p_identifier, p_method)
	##
	_local args << _self.parse_args("(",")")
	>> jpn_method_invocation.new(p_identifier, p_method, args)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_args(p_p1, p_p2)
	##
	.scanner.get()
	.operator_stack.push(_unset) # forget about the current operator
	
	_local args << _self.do_parse_args(p_p1, p_p2)
	
	.scanner.get()
	.operator_stack.pop()
	>> args
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.do_parse_args(p_p1, p_p2)
	##
	_local args << rope.new()
	_loop
		_local lex << .scanner.peek()
		_if lex.is_separator? _orif lex.is_operator?
		_then
			_if lex.value = p_p2
			_then
				_leave
			_elif lex.value = ","
			_then
				.scanner.get()
				_continue
			_endif
		_endif
		args.add(_self.parse_expression_until(p_p2))

		_if args.size > 1000 _then condition.raise(:deco_decompiler_error, :string, write_string("More then 100 parameters, likely a Java decompiler error")) _endif 
	_endloop
	>> args
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_array_args()
	##
	_local args << rope.new()
	_self.ensure_separator("[")
	_loop
		_local lex << .scanner.peek()
		_if lex.is_separator?
		_then
			_if lex.value = "]"
			_then
				_leave
			_elif lex.value = ","
			_then
				.scanner.get()
				_continue
			_endif
		_endif
		args.add(_self.parse_expression())
	_endloop
	_self.ensure_separator("]")
	>> args
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_package()
	##
	_self.ensure_keyword("package")
	_local type << _self.parse_dotted_type()
	_self.ensure_separator(";")

	_return jpn_package.new(type)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_import()
	##
	_self.ensure_keyword("import")
	_local type << _self.parse_dotted_type()
	_self.ensure_separator(";")

	_return jpn_import.new(type)
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.parse_dotted_type()
	##
	_local name_lex << .scanner.get()
	_local type << jpn_type.new(name_lex)
	_loop
		_local lex << .scanner.peek()
		_if lex.is_separator?(".")
		_then
			lex << .scanner.get()
			type << type.become_dotted(.scanner.get())
		_else
			_leave 
		_endif
	_endloop
	>> type
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.ensure_operator(p_op)
	_local l << .scanner.get()
	_if l.is_operator?.not
	_then
		condition.raise(:deco_expected_operator, :line, l.line, :column, l.column, :operator, p_op, :instead, l.value)
	_endif
	_if l.value <> p_op.write_string
	_then
		condition.raise(:deco_expected_operator, :line, l.line, :column, l.column, :operator, p_op, :instead, l.value)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.ensure_separator(p_sep)
	_local l << .scanner.get()
	_if l.is_separator?.not
	_then
		condition.raise(:deco_expected_separator, :line, l.line, :column, l.column, :separator, p_sep, :instead, l.value)
	_endif
	_if l.value <> p_sep.write_string
	_then
		condition.raise(:deco_expected_separator, :line, l.line, :column, l.column, :separator, p_sep, :instead, l.value)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.ensure_keyword(p_keyword)
	_local l << .scanner.get()
	_if l.is_keyword?.not
	_then
		condition.raise(:deco_expected_keyword, :line, l.line, :column, l.column, :keyword, p_keyword, :instead, l.value)
	_endif
	_if l.value <> p_keyword
	_then
		condition.raise(:deco_expected_keyword, :line, l.line, :column, l.column, :keyword, p_keyword, :instead, l.value)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.ensure_identifier(p_identifier)
	_local l << .scanner.get()
	_if l.is_identifier?.not
	_then
		condition.raise(:deco_expected_identifier, :line, l.line, :column, l.column, :identifier, p_identifier, :instead, l.value)
	_endif
	_if l.value <> p_identifier
	_then
		condition.raise(:deco_expected_identifier, :line, l.line, :column, l.column, :identifier, p_identifier, :instead, l.value)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.optional_keyword(p_keyword)
	_local l << .scanner.peek()
	_if l.is_keyword? _andif l.value = p_keyword
	_then
		.scanner.get()
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={jar_decompiler})
_private _method java_parser.check_eof(p_lex, p_what)
	##
	_if p_lex.is_eof?
	_then
		condition.raise(:deco_unexpected_eof, :line, p_lex.line, :column, p_lex.column,
				:while_doing, p_what)
	_endif
_endmethod
$
